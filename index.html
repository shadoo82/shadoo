<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Detalle del Símbolo</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    body {
      background-color: #1a1a1a;
      color: #ffffff;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }
    #local-time {
      text-align: center;
      margin-bottom: 5px;
      color: #cccccc;
      font-size: 14px;
    }
    #current-price {
      text-align: center;
      margin-bottom: 5px;
      color: #00ff00;
      font-size: 16px;
    }
    #stats-timestamp {
      text-align: center;
      margin-bottom: 20px;
      font-size: 14px;
    }
    #stats-timestamp p {
      margin: 2px 0;
      color: #cccccc;
    }
    .container {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .panel {
      flex: 1;
      border: 1px solid #444;
      background-color: #2f2f2f;
      padding: 5px 10px 10px 10px;
      min-width: 300px;
    }
    .title-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      width: 100%;
      text-align: center;
      margin-top: -5px;
    }
    .total-count {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 5px;
      text-align: center;
    }
    .asks-total {
      color: #ff0000;
    }
    .bids-total {
      color: #55ff55;
    }
    .indicator-circle {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    .indicator-circle-start {
      margin-right: 5px;
    }
    .indicator-circle-end {
      margin-left: 5px;
    }
    .circle-red {
      background-color: #ff0000 !important;
    }
    .circle-green {
      background-color: #00ff00 !important;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: #2a2a2a;
      border: 1px solid #444;
      margin-bottom: 10px;
      font-size: 10px;
    }
    th, td {
      padding: 4px;
      border: 1px solid #444;
      position: relative;
      cursor: pointer;
      line-height: 1.2;
      font-size: 10px;
    }
    th {
      background-color: #333;
      color: #00ff00;
      font-weight: 500;
      text-align: center;
    }
    td {
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    td span {
      display: inline-block;
      width: 100%;
      text-align: center;
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    td::selection, td span::selection {
      background: rgba(0, 255, 0, 0.3);
    }
    td::-moz-selection, td span::-moz-selection {
      background: rgba(0, 255, 0, 0.3);
    }
    .ask-row { color: #cccccc; }
    .bid-row { color: #cccccc; }
    tr:hover { background-color: #3a3a3a; }
    .highlight-top {
      background-color: rgba(255, 255, 0, 0.2);
      color: #ffffff;
      font-weight: bold;
    }
    .color-transparent {
      background-color: transparent;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-blue {
      background-color: #090ef5;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-blue td {
      color: #ffffff;
    }
    .color-yellow {
      background-color: #e0f30a;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-yellow td {
      color: #000000;
    }
    .color-orange {
      background-color: #f5550f;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-orange td {
      color: #000000;
    }
    .bold-row td {
      font-weight: bold;
    }
    .highlight-red {
      background-color: rgba(249, 12, 12, 0.5) !important;
      transition: background-color 1s ease-out;
    }
    .highlight-red td {
      color: #ffffff !important;
      font-weight: bold;
    }
    tr.highlight-green {
      background-color: #00ff00 !important;
      transition: background-color 1s ease-out;
    }
    tr.highlight-green td {
      color: #000000 !important;
      font-weight: bold;
    }
    .legend {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-top: 10px;
    }
    .legend-row {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      border-radius: 3px;
      font-size: 10px;
      background-color: #2f2f2f;
      color: #cccccc;
      line-height: 1.2;
    }
    .legend .bid-updated-legend {
      background-color: #00ff00 !important;
      color: #000000 !important;
    }
    .copied {
      background-color: rgba(0, 255, 0, 0.3);
      transition: background-color 0.5s ease;
    }
    .price-cell:hover {
      background-color: rgba(0, 255, 0, 0.1);
      transition: none;
    }
    .highlight-total {
      background-color: #004d00;
      padding: 2px 4px;
      border-radius: 3px;
    }
    .error-message {
      color: #ff5555;
      text-align: center;
      margin: 10px 0;
      font-size: 14px;
    }
    #chart-container {
      width: 100%;
      height: 400px;
      margin-top: 20px;
      background-color: #2f2f2f;
      border: 1px solid #444;
      border-radius: 5px;
    }
    .chart-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      justify-content: center;
      align-items: center;
    }
    .chart-controls button, .chart-controls select {
      background-color: #333;
      color: #ffffff;
      border: 1px solid #444;
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 3px;
    }
    .chart-controls button:hover, .chart-controls select:hover {
      background-color: #444;
    }
    .select-price-btn {
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      font-size: 16px;
      color: #00ff00;
    }
    .select-price-btn:hover {
      opacity: 0.8;
    }
    .select-circle {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #444;
      cursor: pointer;
    }
    .select-circle:hover {
      background-color: #666;
    }
    .selected-row {
      background-color: rgba(0, 255, 0, 0.2);
    }
    .pair-selector, .timezone-selector {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 10px;
      justify-content: flex-start;
    }
    .pair-selector input, .timezone-selector select {
      background-color: #333;
      color: #ffffff;
      border: 1px solid #444;
      padding: 5px 10px;
      font-size: 14px;
      border-radius: 3px;
      width: 150px;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <p id="local-time">Cargando hora...</p>
  <p id="current-price">Precio Actual: Cargando...</p>
  <div id="stats-timestamp">
    <p>Diferencia del libro de órdenes procesada: <span id="diff-orderbook">0</span></p>
    <p>Total de precios procesados: <span id="total-prices">0</span></p>
    <p>Estado de la Conexión: <span id="connection-status">Conectando...</span></p>
  </div>
  <div id="error-message" class="error-message"></div>

  <div class="timezone-selector">
    <label for="timezone-selector">Zona Horaria: </label>
    <select id="timezone-selector" onchange="updateTimeZone()">
      <option value="-12">UTC-12:00</option>
      <option value="-11">UTC-11:00</option>
      <option value="-10">UTC-10:00</option>
      <option value="-9">UTC-09:00</option>
      <option value="-8">UTC-08:00</option>
      <option value="-7">UTC-07:00</option>
      <option value="-6">UTC-06:00</option>
      <option value="-5" selected>UTC-05:00</option>
      <option value="-4">UTC-04:00</option>
      <option value="-3">UTC-03:00</option>
      <option value="-2">UTC-02:00</option>
      <option value="-1">UTC-01:00</option>
      <option value="0">UTC+00:00</option>
      <option value="1">UTC+01:00</option>
      <option value="2">UTC+02:00</option>
      <option value="3">UTC+03:00</option>
      <option value="4">UTC+04:00</option>
      <option value="5">UTC+05:00</option>
      <option value="6">UTC+06:00</option>
      <option value="7">UTC+07:00</option>
      <option value="8">UTC+08:00</option>
      <option value="9">UTC+09:00</option>
      <option value="10">UTC+10:00</option>
      <option value="11">UTC+11:00</option>
      <option value="12">UTC+12:00</option>
      <option value="13">UTC+13:00</option>
      <option value="14">UTC+14:00</option>
    </select>
  </div>

  <div class="pair-selector">
    <input list="pair-selector" id="pair-search" placeholder="Buscar par (ej. BTCUSDT)" value="BTCUSDT" oninput="filterPairs()" onchange="changePair()" onclick="this.value=''" />
    <datalist id="pair-selector"></datalist>
  </div>
  <div class="chart-controls">
    <button onclick="autoScaleChart()">Escalar Automáticamente</button>
    <select id="timeframe-selector" onchange="changeTimeframe()">
      <option value="15m">15m</option>
      <option value="1h" selected>1h</option>
      <option value="4h">4h</option>
      <option value="1d">1d</option>
    </select>
    <button onclick="exportLines()">Exportar/Importar Líneas</button>
    <select id="zones-selector" onchange="updateZones()">
      <option value="10">10</option>
      <option value="15">15</option>
      <option value="20">20</option>
      <option value="25">25</option>
      <option value="30" selected>30</option>
      <option value="100">100</option>
    </select>
  </div>
  <div id="chart-container"></div>

  <div class="container">
    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="bids-indicator-start"></span>
        <div class="total-count bids-total" id="bids-total">BIDS - 0 | TOTAL: 0</div>
        <span class="indicator-circle indicator-circle-end" id="bids-indicator-end"></span>
      </div>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Edad</th>
            <th>Precio</th>
            <th>Cant.</th>
            <th>USDT</th>
            <th>% al precio</th>
            <th>Acum. USDT</th>
            <th>Acum. Cant.</th>
            <th>Hits</th>
            <th>Seleccionar</th>
          </tr>
        </thead>
        <tbody id="bids-body"></tbody>
      </table>
      <div class="legend">
        <div class="legend-row bid-updated-legend" style="background-color: #00ff00 !important; color: #000000 !important;">Bid actualizado (Compra, Texto Negro)</div>
        <div class="legend-row" style="background-color: #090ef5 !important; color: #ffffff !important;">Bids dentro del 0.5% al 1% del precio marcado (Texto Blanco)</div>
        <div class="legend-row" style="background-color: #e0f30a !important; color: #000000 !important;">Bids dentro del 0.1% al 0.5% del precio marcado (Texto Negro)</div>
        <div class="legend-row" style="background-color: #f5550f !important; color: #000000 !important;">Bids dentro del 0.1% del precio marcado (Texto Negro)</div>
      </div>
    </div>

    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="asks-indicator-start"></span>
        <div class="total-count asks-total" id="asks-total">ASKS - 0 | TOTAL: 0</div>
        <span class="indicator-circle indicator-circle-end" id="asks-indicator-end"></span>
      </div>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Edad</th>
            <th>Precio</th>
            <th>Cant.</th>
            <th>USDT</th>
            <th>% al precio</th>
            <th>Acum. USDT</th>
            <th>Acum. Cant.</th>
            <th>Hits</th>
            <th>Seleccionar</th>
          </tr>
        </thead>
        <tbody id="asks-body"></tbody>
      </table>
      <div class="legend">
        <div class="legend-row" style="background-color: rgba(249, 12, 12, 0.5) !important; color: #ffffff !important;">Ask actualizado (Venta, Texto Blanco)</div>
        <div class="legend-row" style="background-color: #090ef5 !important; color: #ffffff !important;">Asks dentro del 0.5% al 1% del precio marcado (Texto Blanco)</div>
        <div class="legend-row" style="background-color: #e0f30a !important; color: #000000 !important;">Asks dentro del 0.1% al 0.5% del precio marcado (Texto Negro)</div>
        <div class="legend-row" style="background-color: #f5550f !important; color: #000000 !important;">Asks dentro del 0.1% del precio marcado (Texto Negro)</div>
      </div>
    </div>
  </div>

  <script>
    let symbol = "BTCUSDT";
    let currentTimeframe = "1h";
    let tickerSocket = null;
    let depthSocket = null;
    let klineSocket = null;

    let currentPrice = 0;
    let asksData = [];
    let bidsData = [];
    let asksProcessed = 0;
    let bidsProcessed = 0;
    let diffOrderbookProcessed = 0;
    let pendingUpdate = false;
    let lastPriceUpdateTime = 0;
    let lastDepthUpdateTime = 0;
    let isInteracting = false;
    const INTERACTION_TIMEOUT_MS = 2000;
    const rowColors = new Map();
    const COLOR_DURATION_MS = 5000;
    let selectedPrices = new Map();
    let lastTableUpdate = 0;
    const TABLE_UPDATE_DEBOUNCE_MS = 100;
    let maxZones = 30;

    let chart = null;
    let candlestickSeries = null;
    let candlesData = [];
    let lastHoveredPrice = null;
    let markerTimeout = null;
    let allPairs = [];

    // Cargar la zona horaria desde localStorage o usar UTC-05:00 por defecto
    let utcOffset = parseInt(localStorage.getItem('utcOffset')) || -5;

    async function fetchPairs() {
      try {
        const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
        const data = await response.json();
        allPairs = data.symbols
          .filter(s => s.symbol.endsWith('USDT') && s.status === 'TRADING')
          .map(s => s.symbol)
          .sort();
        populatePairSelector();
      } catch (error) {
        console.error('Error al obtener los pares:', error);
        document.getElementById("error-message").innerText = "Error al cargar los pares desde Binance Futures: " + error.message;
      }
    }

    function populatePairSelector() {
      const pairSelector = document.getElementById("pair-selector");
      if (!pairSelector) {
        console.error("No se encontró el elemento pair-selector");
        return;
      }
      pairSelector.innerHTML = '';
      allPairs.forEach(pair => {
        const option = document.createElement("option");
        option.value = pair;
        option.text = pair;
        pairSelector.appendChild(option);
      });
      document.getElementById("pair-search").value = symbol;
    }

    function filterPairs() {
      const pairSearch = document.getElementById("pair-search");
      pairSearch.value = pairSearch.value.toUpperCase();
      const searchInput = pairSearch.value;
      const pairSelector = document.getElementById("pair-selector");
      pairSelector.innerHTML = '';
      const filteredPairs = allPairs.filter(pair => pair.includes(searchInput));
      filteredPairs.forEach(pair => {
        const option = document.createElement("option");
        option.value = pair;
        option.text = pair;
        pairSelector.appendChild(option);
      });
    }

    function changePair() {
      const newSymbol = document.getElementById("pair-search").value.toUpperCase();
      if (newSymbol && newSymbol !== symbol && allPairs.includes(newSymbol)) {
        symbol = newSymbol;
        asksData = [];
        bidsData = [];
        asksProcessed = 0;
        bidsProcessed = 0;
        diffOrderbookProcessed = 0;
        currentPrice = 0;
        candlesData = [];
        selectedPrices.clear();

        setupSockets();
        loadHistoricalKlines();

        document.getElementById("pair-search").value = symbol;
      }
    }

    function initializeChart() {
      const chartContainer = document.getElementById("chart-container");
      if (!chartContainer) {
        console.error("No se encontró el contenedor del gráfico");
        document.getElementById("error-message").innerText = "No se encontró el contenedor del gráfico";
        return;
      }
      chart = LightweightCharts.createChart(chartContainer, {
        width: chartContainer.offsetWidth,
        height: 400,
        layout: {
          background: { type: 'solid', color: '#2f2f2f' },
          textColor: '#d1d4dc',
        },
        grid: {
          vertLines: { color: '#444' },
          horzLines: { color: '#444' },
        },
        timeScale: {
          timeVisible: true,
          secondsVisible: false,
        },
        rightPriceScale: {
          borderColor: '#444',
        },
        handleScroll: {
          mouseWheel: true,
          pressedMouseMove: true,
          horzTouchDrag: true,
          vertTouchDrag: true,
        },
        handleScale: {
          axisPressedMouseMove: true,
          mouseWheel: true,
          pinch: true,
        },
      });

      candlestickSeries = chart.addCandlestickSeries({
        upColor: '#00ff00',
        downColor: '#ff0000',
        borderVisible: false,
        wickUpColor: '#00ff00',
        wickDownColor: '#ff0000',
      });

      chart.applyOptions({
        priceScale: {
          scaleMargins: { top: 0.1, bottom: 0.1 },
        },
      });

      setupChartInteractions();
    }

    function getVisiblePriceRange() {
      if (!candlesData || candlesData.length === 0) return { minPrice: 0, maxPrice: 0 };
      const visibleRange = chart.timeScale().getVisibleRange();
      if (!visibleRange) return { minPrice: 0, maxPrice: 0 };
      const visibleCandles = candlesData.filter(candle => 
        candle.time >= visibleRange.from && candle.time <= visibleRange.to
      );
      if (visibleCandles.length === 0) return { minPrice: 0, maxPrice: 0 };
      const minPrice = Math.min(...visibleCandles.map(candle => candle.low));
      const maxPrice = Math.max(...visibleCandles.map(candle => candle.high));
      return { minPrice, maxPrice };
    }

    function setupChartInteractions() {
      chart.subscribeCrosshairMove((param) => {
        if (!param || !param.point) return;
        const y = param.point.y;
        const chartContainer = document.getElementById("chart-container");
        const containerHeight = chartContainer.offsetHeight;
        const scaleMargins = { top: 0.1, bottom: 0.1 };
        const effectiveHeight = containerHeight * (1 - scaleMargins.top - scaleMargins.bottom);
        const heightOffset = containerHeight * scaleMargins.top;
        const adjustedY = y - heightOffset;
        if (adjustedY < 0 || adjustedY > effectiveHeight) return;
        const { minPrice, maxPrice } = getVisiblePriceRange();
        const priceRangeLength = maxPrice - minPrice;
        if (priceRangeLength <= 0) return;
        const pricePerPixel = priceRangeLength / effectiveHeight;
        const price = maxPrice - (adjustedY * pricePerPixel);
        if (isNaN(price)) return;

        let closestPrice = null;
        let closestDistance = Infinity;
        let closestLine = null;

        selectedPrices.forEach((lineData, selectedPrice) => {
          const distance = Math.abs(selectedPrice - price);
          if (distance < closestDistance) {
            closestDistance = distance;
            closestPrice = selectedPrice;
            closestLine = lineData;
          }
        });

        const threshold = priceRangeLength * 0.03;
        if (closestDistance < threshold) {
          lastHoveredPrice = closestPrice;
          if (closestLine && !closestLine.marker) {
            closestLine.marker = closestLine.series.createPriceLine({
              price: closestPrice,
              color: closestLine.isAsk ? '#ff0000' : '#00ff00',
              lineWidth: 1,
              lineStyle: LightweightCharts.LineStyle.Dashed,
              title: '✖ Cerrar',
            });
          }

          if (markerTimeout) {
            clearTimeout(markerTimeout);
            markerTimeout = null;
          }

          markerTimeout = setTimeout(() => {
            if (lastHoveredPrice === closestPrice) {
              if (closestLine.marker) {
                closestLine.series.removePriceLine(closestLine.marker);
                closestLine.marker = null;
                lastHoveredPrice = null;
              }
            }
          }, 2000);
        } else {
          if (!markerTimeout) {
            markerTimeout = setTimeout(() => {
              selectedPrices.forEach((lineData, priceKey) => {
                if (lineData.marker && priceKey === lastHoveredPrice) {
                  lineData.series.removePriceLine(lineData.marker);
                  lineData.marker = null;
                  lastHoveredPrice = null;
                }
              });
            }, 2000);
          }
        }
      });

      chart.subscribeClick((param) => {
        if (!param || !param.point) return;
        const y = param.point.y;
        const chartContainer = document.getElementById("chart-container");
        const containerHeight = chartContainer.offsetHeight;
        const scaleMargins = { top: 0.1, bottom: 0.1 };
        const effectiveHeight = containerHeight * (1 - scaleMargins.top - scaleMargins.bottom);
        const heightOffset = containerHeight * scaleMargins.top;
        const adjustedY = y - heightOffset;
        if (adjustedY < 0 || adjustedY > effectiveHeight) return;
        const { minPrice, maxPrice } = getVisiblePriceRange();
        const priceRangeLength = maxPrice - minPrice;
        if (priceRangeLength <= 0) return;
        const pricePerPixel = priceRangeLength / effectiveHeight;
        const price = maxPrice - (adjustedY * pricePerPixel);
        if (isNaN(price)) return;

        let closestPrice = null;
        let closestDistance = Infinity;

        if (lastHoveredPrice !== null && selectedPrices.has(lastHoveredPrice)) {
          closestPrice = lastHoveredPrice;
          closestDistance = 0;
        } else {
          selectedPrices.forEach((selectedPrice) => {
            const distance = Math.abs(selectedPrice - price);
            if (distance < closestDistance) {
              closestDistance = distance;
              closestPrice = selectedPrice;
            }
          });
        }

        const threshold = priceRangeLength * 0.03;
        if (closestDistance < threshold && closestPrice !== null) {
          drawSelectedPriceLine(closestPrice, null, false);
          updateTableRowsAfterDeselect(closestPrice);
          lastHoveredPrice = null;
          if (markerTimeout) {
            clearTimeout(markerTimeout);
            markerTimeout = null;
          }
          ensureChartVisibility();
        }
      });
    }

    function updateTableRowsAfterDeselect(price) {
      const tableBodies = ['asks-body', 'bids-body'];
      tableBodies.forEach(tableId => {
        const tableBody = document.getElementById(tableId);
        Array.from(tableBody.children).forEach(row => {
          const rowPrice = parseFloat(row.cells[2].textContent);
          if (rowPrice === price) {
            row.classList.remove("selected-row");
            updateSelectButton(row, price);
          }
        });
      });
    }

    function ensureChartVisibility() {
      if (chart && candlestickSeries && candlesData.length > 0) {
        candlestickSeries.setData(candlesData);
        chart.timeScale().fitContent();
      }
    }

    function saveHistoricalKlines() {
      const key = `${symbol}_${currentTimeframe}_klines`;
      localStorage.setItem(key, JSON.stringify(candlesData));
    }

    function loadHistoricalKlinesFromStorage() {
      const key = `${symbol}_${currentTimeframe}_klines`;
      const savedData = localStorage.getItem(key);
      if (savedData) {
        candlesData = JSON.parse(savedData);
        if (candlestickSeries && candlesData.length > 0) {
          candlestickSeries.setData(candlesData);
          chart.timeScale().fitContent();
        }
        return true;
      }
      return false;
    }

    async function loadHistoricalKlines() {
      if (loadHistoricalKlinesFromStorage()) {
        return;
      }
      try {
        const klineRestUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${currentTimeframe}&limit=100`;
        const response = await fetch(klineRestUrl);
        if (!response.ok) {
          throw new Error(`Error HTTP! Estado: ${response.status}`);
        }
        const data = await response.json();
        if (!Array.isArray(data)) {
          throw new Error("Formato de datos de Kline inválido");
        }
        candlesData = data.map(kline => {
          const time = Math.floor(kline[0] / 1000);
          const open = parseFloat(kline[1]);
          const high = parseFloat(kline[2]);
          const low = parseFloat(kline[3]);
          const close = parseFloat(kline[4]);
          if (isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
            throw new Error("Valores de Kline inválidos");
          }
          return { time, open, high, low, close };
        });
        if (candlestickSeries && candlesData.length > 0) {
          candlestickSeries.setData(candlesData);
          chart.timeScale().fitContent();
          saveHistoricalKlines();
        }
      } catch (error) {
        console.error('Error al cargar datos históricos de Kline:', error);
        document.getElementById("error-message").innerText = "Error al cargar datos históricos: " + error.message;
      }
    }

    function setupTickerSocket() {
      if (tickerSocket) {
        tickerSocket.close();
      }
      const wsUrl = `wss://fstream.binance.com/stream?streams=${symbol.toLowerCase()}@ticker`;
      tickerSocket = new WebSocket(wsUrl);

      tickerSocket.onopen = () => {
        console.log('Conexión de ticker WebSocket abierta');
        document.getElementById("connection-status").innerText = "Conectado (Ticker)";
      };

      tickerSocket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          if (message.stream && message.data) {
            const data = message.data;
            const startTime = performance.now();
            const newPrice = parseFloat(data.c);
            if (isNaN(newPrice)) {
              throw new Error("Valor de precio inválido en datos de ticker");
            }
            currentPrice = newPrice;
            document.getElementById("current-price").innerText = `${symbol} Precio: ${formatPrice(currentPrice)}`;
            const endTime = performance.now();
            const timeSinceLastUpdate = startTime - lastPriceUpdateTime;
            lastPriceUpdateTime = startTime;
            updateTimestamp();
            scheduleTableUpdate();
          } else {
            console.warn("Mensaje de ticker WebSocket inválido:", message);
            document.getElementById("error-message").innerText = "Mensaje de ticker WebSocket inválido";
          }
        } catch (error) {
          console.error('Error al procesar datos de ticker:', error);
          document.getElementById("error-message").innerText = "Error al procesar datos de ticker: " + error.message;
        }
      };

      tickerSocket.onerror = (error) => {
        console.error('Error en WebSocket de ticker:', error);
        document.getElementById("connection-status").innerText = "Error de Conexión (Ticker)";
        document.getElementById("error-message").innerText = "Error en WebSocket de ticker: Posible problema de CORS. Sirve el archivo desde un servidor local o desactiva CORS.";
      };

      tickerSocket.onclose = () => {
        console.log('Conexión de ticker WebSocket cerrada');
        document.getElementById("connection-status").innerText = "Desconectado (Ticker)";
        setTimeout(setupTickerSocket, 5000);
      };
    }

    function setupDepthSocket() {
      if (depthSocket) {
        depthSocket.close();
      }
      const wsUrl = `wss://fstream.binance.com/stream?streams=${symbol.toLowerCase()}@depth20@100ms`;
      depthSocket = new WebSocket(wsUrl);

      depthSocket.onopen = () => {
        console.log('Conexión de profundidad WebSocket abierta');
        document.getElementById("connection-status").innerText = "Conectado (Depth)";
      };

      depthSocket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          if (message.stream && message.data) {
            const data = message.data;
            const startTime = performance.now();
            const now = Date.now();

            if (data.asks) {
              asksData = updateOrders(asksData, data.asks, now, true);
              asksProcessed += data.asks.length;
            }
            if (data.bids) {
              bidsData = updateOrders(bidsData, data.bids, now, false);
              bidsProcessed += data.bids.length;
            }

            diffOrderbookProcessed = Math.abs(asksProcessed - bidsProcessed);

            if (currentPrice > 0) {
              asksData = asksData.filter(item => {
                const diff = Math.abs((item.price - currentPrice) / currentPrice) * 100;
                return diff <= 10;
              });
              bidsData = bidsData.filter(item => {
                const diff = Math.abs((item.price - currentPrice) / currentPrice) * 100;
                return diff <= 10;
              });
            }

            asksData.sort((a, b) => b.usdt - a.usdt);
            bidsData.sort((a, b) => b.usdt - a.usdt);

            asksData = asksData.slice(0, maxZones);
            bidsData = bidsData.slice(0, maxZones);

            document.getElementById("diff-orderbook").innerText = diffOrderbookProcessed.toLocaleString();
            document.getElementById("asks-total").innerText = `ASKS - ${asksData.length} | TOTAL: ${asksProcessed.toLocaleString()}`;
            document.getElementById("bids-total").innerText = `BIDS - ${bidsData.length} | TOTAL: ${bidsProcessed.toLocaleString()}`;
            const totalPrices = asksProcessed + bidsProcessed;
            document.getElementById("total-prices").innerText = totalPrices.toLocaleString();

            if (totalPrices > 250000) {
              document.getElementById("total-prices").classList.add("highlight-total");
            }

            const asksIndicatorStart = document.getElementById("asks-indicator-start");
            const asksIndicatorEnd = document.getElementById("asks-indicator-end");
            const bidsIndicatorStart = document.getElementById("bids-indicator-start");
            const bidsIndicatorEnd = document.getElementById("bids-indicator-end");
            asksIndicatorStart.classList.remove("circle-red", "circle-green");
            asksIndicatorEnd.classList.remove("circle-red", "circle-green");
            bidsIndicatorStart.classList.remove("circle-red", "circle-green");
            bidsIndicatorEnd.classList.remove("circle-red", "circle-green");
            if (asksProcessed > bidsProcessed) {
              asksIndicatorStart.classList.add("circle-red");
              asksIndicatorEnd.classList.add("circle-red");
            } else if (bidsProcessed > asksProcessed) {
              bidsIndicatorStart.classList.add("circle-green");
              bidsIndicatorEnd.classList.add("circle-green");
            }

            scheduleTableUpdate();
          } else {
            console.warn("Mensaje de profundidad WebSocket inválido:", message);
            document.getElementById("error-message").innerText = "Mensaje de profundidad WebSocket inválido";
          }
        } catch (error) {
          console.error('Error al procesar datos de profundidad:', error);
          document.getElementById("error-message").innerText = "Error al procesar datos de profundidad: " + error.message;
        }
      };

      depthSocket.onerror = (error) => {
        console.error('Error en WebSocket de profundidad:', error);
        document.getElementById("connection-status").innerText = "Error de Conexión (Depth)";
        document.getElementById("error-message").innerText = "Error en WebSocket de profundidad: Posible problema de CORS. Sirve el archivo desde un servidor local o desactiva CORS.";
      };

      depthSocket.onclose = () => {
        console.log('Conexión de profundidad WebSocket cerrada');
        document.getElementById("connection-status").innerText = "Desconectado (Depth)";
        setTimeout(setupDepthSocket, 5000);
      };
    }

    function setupKlineSocket() {
      if (klineSocket) {
        klineSocket.close();
      }
      const wsUrl = `wss://fstream.binance.com/stream?streams=${symbol.toLowerCase()}@kline_${currentTimeframe}`;
      klineSocket = new WebSocket(wsUrl);

      klineSocket.onopen = () => {
        console.log('Conexión de Kline WebSocket abierta');
        document.getElementById("connection-status").innerText = "Conectado (Kline)";
      };

      klineSocket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          if (message.stream && message.data) {
            const kline = message.data.k;
            const time = Math.floor(kline.t / 1000);
            const open = parseFloat(kline.o);
            const high = parseFloat(kline.h);
            const low = parseFloat(kline.l);
            const close = parseFloat(kline.c);
            const isKlineClosed = kline.x;

            if (isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
              throw new Error("Valores de Kline inválidos");
            }

            const candle = { time, open, high, low, close };

            const lastCandleTime = candlesData.length > 0 ? candlesData[candlesData.length - 1].time : null;
            if (lastCandleTime && candle.time === lastCandleTime) {
              const lastCandleIndex = candlesData.findIndex(c => c.time === candle.time);
              if (lastCandleIndex !== -1) {
                candlesData[lastCandleIndex] = candle;
                candlestickSeries.update(candle);
              }
            } else if (!lastCandleTime || candle.time > lastCandleTime) {
              candlesData.push(candle);
              if (candlesData.length > 1000) {
                candlesData.shift();
              }
              candlestickSeries.setData(candlesData);
              chart.timeScale().scrollToRealTime();
              if (isKlineClosed) {
                saveHistoricalKlines();
              }
            }
          } else {
            console.warn("Mensaje de Kline WebSocket inválido:", message);
            document.getElementById("error-message").innerText = "Mensaje de Kline WebSocket inválido";
          }
        } catch (error) {
          console.error('Error al procesar datos de Kline:', error);
          document.getElementById("error-message").innerText = "Error al procesar datos de Kline: " + error.message;
        }
      };

      klineSocket.onerror = (error) => {
        console.error('Error en WebSocket de Kline:', error);
        document.getElementById("connection-status").innerText = "Error de Conexión (Kline)";
        document.getElementById("error-message").innerText = "Error en WebSocket de Kline: Posible problema de CORS. Sirve el archivo desde un servidor local o desactiva CORS.";
      };

      klineSocket.onclose = () => {
        console.log('Conexión de Kline WebSocket cerrada');
        document.getElementById("connection-status").innerText = "Desconectado (Kline)";
        setTimeout(setupKlineSocket, 5000);
      };
    }

    function setupSockets() {
      setupTickerSocket();
      setupDepthSocket();
      setupKlineSocket();
    }

    let isChangingTimeframe = false;

    function changeTimeframe() {
      if (isChangingTimeframe) return;
      isChangingTimeframe = true;
      const newTimeframe = document.getElementById("timeframe-selector").value;
      if (newTimeframe === currentTimeframe) {
        isChangingTimeframe = false;
        return;
      }
      currentTimeframe = newTimeframe;

      candlesData = [];

      loadHistoricalKlines().then(() => {
        setupKlineSocket();
        ensureChartVisibility();
        isChangingTimeframe = false;
      }).catch((error) => {
        console.error('Error al cambiar el timeframe:', error);
        isChangingTimeframe = false;
        document.getElementById("error-message").innerText = "Error al cambiar el timeframe: " + error.message;
      });
    }

    function autoScaleChart() {
      if (chart) {
        chart.timeScale().fitContent();
        chart.priceScale().applyOptions({
          autoScale: true,
        });
      }
    }

    function exportLines() {
      const linesData = Array.from(selectedPrices.entries()).map(([price, line]) => ({
        price: price,
        color: line.isAsk ? '#ff0000' : '#00ff00',
        isAsk: line.isAsk,
      }));
      const blob = new Blob([JSON.stringify(linesData)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'lineas_seleccionadas.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function updateZones() {
      maxZones = parseInt(document.getElementById("zones-selector").value);
      scheduleTableUpdate();
    }

    function initializeApp() {
      fetchPairs();
      initializeChart();
      if (chart && candlestickSeries) {
        loadHistoricalKlines().then(() => {
          loadSelectedPrices();
        }).catch((error) => {
          console.error('Error al inicializar la aplicación:', error);
          document.getElementById("error-message").innerText = "Error al inicializar la aplicación: " + error.message;
        });
      }
      // Configurar la zona horaria seleccionada
      const timezoneSelector = document.getElementById("timezone-selector");
      timezoneSelector.value = utcOffset;
      // Iniciar WebSocket
      setupSockets();
    }

    function waitForLightweightCharts() {
      if (typeof LightweightCharts !== 'undefined') {
        initializeApp();
      } else {
        console.warn("Lightweight Charts no está cargado, reintentando...");
        setTimeout(waitForLightweightCharts, 100);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      waitForLightweightCharts();
    });

    function saveSelectedPrices() {
      const prices = Array.from(selectedPrices.entries()).map(([price, line]) => ({
        price: price,
        isAsk: line.isAsk,
      }));
      localStorage.setItem('selectedPrices', JSON.stringify(prices));
    }

    function loadSelectedPrices() {
      const savedPrices = localStorage.getItem('selectedPrices');
      if (savedPrices) {
        const prices = JSON.parse(savedPrices);
        prices.forEach(item => {
          const priceNum = parseFloat(item.price);
          const isAsk = item.isAsk;
          if (!isNaN(priceNum) && !selectedPrices.has(priceNum)) {
            drawSelectedPriceLine(priceNum, null, isAsk);
          }
        });
      }
    }

    function drawSelectedPriceLine(price, row, isAsk) {
      if (selectedPrices.has(price)) {
        const line = selectedPrices.get(price);
        if (line.marker) {
          line.series.removePriceLine(line.marker);
        }
        chart.removeSeries(line.series);
        selectedPrices.delete(price);
        if (row) {
          row.classList.remove("selected-row");
          updateSelectButton(row, price);
        }
        saveSelectedPrices();
        ensureChartVisibility();
        return;
      }

      const lineColor = isAsk ? '#ff0000' : '#00ff00';
      const lineSeries = chart.addLineSeries({
        color: lineColor,
        lineWidth: 1,
        priceLineVisible: false,
        lastValueVisible: false,
      });

      const now = Math.floor(Date.now() / 1000);
      lineSeries.setData([
        { time: now - 86400, value: price },
        { time: now, value: price },
      ]);

      lineSeries.createPriceLine({
        price: price,
        color: lineColor,
        lineWidth: 1,
        lineStyle: LightweightCharts.LineStyle.Solid,
        title: `Precio: ${formatPrice(price)}`,
      });

      selectedPrices.set(price, { series: lineSeries, price: price, isAsk: isAsk, marker: null });
      if (row) {
        row.classList.add("selected-row");
        updateSelectButton(row, price);
      }
      saveSelectedPrices();
      ensureChartVisibility();
    }

    function updateSelectButton(row, price) {
      const selectCell = row.querySelector('td:last-child');
      if (selectCell) {
        if (selectedPrices.has(price)) {
          selectCell.innerHTML = `<button class="select-price-btn" data-price="${price}">📍</button>`;
        } else {
          selectCell.innerHTML = `<span class="select-circle" data-price="${price}"></span>`;
        }
      }
    }

    function redrawSelectedLines() {
      const pricesToRedraw = Array.from(selectedPrices.entries()).map(([price, lineData]) => ({
        price: price,
        isAsk: lineData.isAsk,
      }));
      selectedPrices.forEach((value, price) => {
        if (value.series) {
          if (value.marker) {
            value.series.removePriceLine(value.marker);
          }
          chart.removeSeries(value.series);
        }
      });
      selectedPrices.clear();
      pricesToRedraw.forEach(item => {
        drawSelectedPriceLine(item.price, null, item.isAsk);
      });
      ensureChartVisibility();
    }

    window.addEventListener('resize', () => {
      if (chart) {
        const chartContainer = document.getElementById("chart-container");
        chart.resize(chartContainer.offsetWidth, 400);
        redrawSelectedLines();
      }
    });

    function setupEventListeners() {
      const tableBodies = document.querySelectorAll('#asks-body, #bids-body');
      tableBodies.forEach(tableBody => {
        const isAsk = tableBody.id === 'asks-body';
        tableBody.addEventListener('click', (event) => {
          const selectBtn = event.target.closest('.select-price-btn, .select-circle');
          if (selectBtn) {
            event.stopPropagation();
            event.preventDefault();
            const price = parseFloat(selectBtn.dataset.price);
            const row = selectBtn.closest('tr');
            if (row) {
              isInteracting = true;
              drawSelectedPriceLine(price, row, isAsk);
              setTimeout(() => {
                isInteracting = false;
              }, INTERACTION_TIMEOUT_MS);
            }
          }
        });

        tableBody.addEventListener('click', (event) => {
          const priceCell = event.target.closest('.price-cell');
          if (priceCell) {
            event.stopPropagation();
            event.preventDefault();
            isInteracting = true;
            copyPriceCell(priceCell);
            setTimeout(() => {
              isInteracting = false;
            }, INTERACTION_TIMEOUT_MS);
          }
        });
      });
    }

    setupEventListeners();

    function scheduleTableUpdate() {
      if (!pendingUpdate) {
        pendingUpdate = true;
        const now = Date.now();
        if (isInteracting) {
          setTimeout(() => {
            pendingUpdate = false;
            scheduleTableUpdate();
          }, TABLE_UPDATE_DEBOUNCE_MS);
          return;
        }
        if (now - lastTableUpdate < TABLE_UPDATE_DEBOUNCE_MS) {
          setTimeout(() => {
            pendingUpdate = false;
            scheduleTableUpdate();
          }, TABLE_UPDATE_DEBOUNCE_MS - (now - lastTableUpdate));
          return;
        }
        requestAnimationFrame(() => {
          updateTables();
          lastTableUpdate = Date.now();
          pendingUpdate = false;
        });
      }
    }

    function updateOrders(existingOrders, newOrders, now, isAsk) {
      const ordersMap = new Map(existingOrders.map(o => [o.price, o]));

      newOrders.forEach(([p, q]) => {
        const price = parseFloat(p);
        const qty = parseFloat(q);
        if (isNaN(price) || isNaN(qty)) {
          console.warn(`Precio o cantidad inválida: precio=${p}, cantidad=${q}`);
          return;
        }
        const usdt = price * qty;

        if (qty === 0) {
          ordersMap.delete(price);
          rowColors.delete(price);
        } else {
          if (ordersMap.has(price)) {
            const existing = ordersMap.get(price);
            const previousHits = existing.hits || 0;

            existing.qty = qty;
            existing.usdt = usdt;
            existing.lastUpdated = now;
            existing.hits = previousHits + 1;
            existing.colorAssignedTime = now;
          } else {
            ordersMap.set(price, {
              price,
              qty,
              usdt,
              lastUpdated: now,
              colorAssignedTime: now,
              hits: 1,
            });
          }
        }
      });

      return Array.from(ordersMap.values());
    }

    function getColorClass(price, markPrice, isAsk, colorAssignedTime, now) {
      if (!markPrice || markPrice === 0) return "color-transparent";
      const diff = ((price - markPrice) / markPrice) * 100;
      const absDiff = Math.abs(diff);
      const colorAge = now - colorAssignedTime;

      if (colorAge > COLOR_DURATION_MS) {
        return "color-transparent";
      }

      if (absDiff <= 0.1) {
        return "color-orange";
      } else if (absDiff > 0.1 && absDiff <= 0.5) {
        return "color-yellow";
      } else if (absDiff > 0.5 && absDiff <= 1) {
        return "color-blue";
      }
      return "color-transparent";
    }

    function updateTables() {
      updateTable("asks-body", asksData, currentPrice, true);
      updateTable("bids-body", bidsData, currentPrice, false);
    }

    function updateTable(tableId, data, markPrice, isAsk) {
      const tableBody = document.getElementById(tableId);
      if (!tableBody) {
        console.error(`No se encontró el cuerpo de la tabla: ${tableId}`);
        return;
      }
      const now = Date.now();

      const existingRows = new Map();
      Array.from(tableBody.children).forEach(row => {
        const price = parseFloat(row.cells[2].textContent);
        if (!isNaN(price)) {
          existingRows.set(price, row);
        }
      });

      let accUsdt = 0;
      let accQty = 0;

      const fragment = document.createDocumentFragment();
      data.forEach((item, idx) => {
        const ageTime = formatAge(now - item.lastUpdated);
        const pct = markPrice ? (((item.price - markPrice) / markPrice) * 100).toFixed(3) : "---";
        
        accUsdt += item.usdt;
        accQty += item.qty;

        let row = existingRows.get(item.price);
        if (!row) {
          row = document.createElement("tr");
          row.className = isAsk ? "ask-row" : "bid-row";
        }

        if (selectedPrices.has(item.price)) {
          row.classList.add("selected-row");
        } else {
          row.classList.remove("selected-row");
        }

        if (idx < 4) {
          row.classList.add("highlight-top");
        } else {
          row.classList.remove("highlight-top");
        }

        const newColorClass = getColorClass(item.price, markPrice, isAsk, item.colorAssignedTime || now, now);
        row.classList.remove("color-transparent", "color-blue", "color-yellow", "color-orange");
        row.classList.add(newColorClass);
        rowColors.set(item.price, newColorClass);

        if (newColorClass !== "color-transparent") {
          row.classList.add("bold-row");
        } else {
          row.classList.remove("bold-row");
        }

        const highlightDuration = 1000;
        const timeSinceUpdate = now - item.lastUpdated;
        if (timeSinceUpdate <= highlightDuration && item.hits > 1) {
          row.classList.add(isAsk ? "highlight-red" : "highlight-green");
        } else {
          row.classList.remove("highlight-red", "highlight-green");
        }

        row.innerHTML = `
          <td>${idx + 1}</td>
          <td>${ageTime}</td>
          <td class="price-cell">${formatPrice(item.price)}</td>
          <td>${formatQty(item.qty)}</td>
          <td>${formatUsdt(item.usdt)}</td>
          <td>${pct}</td>
          <td>${formatUsdt(accUsdt)}</td>
          <td>${formatQty(accQty)}</td>
          <td>${item.hits || 1}</td>
          <td>${selectedPrices.has(item.price) ? `<button class="select-price-btn" data-price="${item.price}">📍</button>` : `<span class="select-circle" data-price="${item.price}"></span>`}</td>
        `;
        fragment.appendChild(row);
        existingRows.delete(item.price);
      });

      existingRows.forEach(row => row.remove());
      tableBody.appendChild(fragment);
    }

    function copyPriceCell(cell) {
      const priceText = cell.textContent.trim();
      navigator.clipboard.writeText(priceText).then(() => {
        cell.classList.add("copied");
      }).catch(err => {
        console.error('Error al copiar el precio:', err);
      });
    }

    function formatPrice(value) {
      if (isNaN(value)) return "0.00";
      return parseFloat(value).toFixed(2);
    }

    function formatQty(value) {
      if (isNaN(value) || value === 0) return "0";
      if (value >= 1_000_000_000) {
        return (value / 1_000_000_000).toFixed(2) + "b";
      } else if (value >= 1_000_000) {
        return (value / 1_000_000).toFixed(2) + "m";
      } else if (value >= 1_000) {
        return (value / 1_000).toFixed(2) + "k";
      } else if (value < 0.001) {
        return value.toFixed(6);
      }
      return parseFloat(value).toFixed(4);
    }

    function formatUsdt(value) {
      if (isNaN(value) || value === 0) return "0.00";
      if (value >= 1_000_000_000) {
        return (value / 1_000_000_000).toFixed(2) + "b";
      } else if (value >= 1_000_000) {
        return (value / 1_000_000).toFixed(2) + "m";
      } else if (value >= 1_000) {
        return (value / 1_000).toFixed(2) + "k";
      } else if (value < 0.01) {
        return value.toFixed(4);
      }
      return parseFloat(value).toFixed(2);
    }

    function formatAge(ms) {
      const seconds = Math.floor(ms / 1000);
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m`;
      const hours = Math.floor(minutes / 60);
      return `${hours}h`;
    }

    function formatUtcOffset(offset) {
      const sign = offset >= 0 ? "+" : "-";
      const absOffset = Math.abs(offset);
      const hours = Math.floor(absOffset).toString().padStart(2, '0');
      const minutes = ((absOffset % 1) * 60).toString().padStart(2, '0');
      return `UTC${sign}${hours}:${minutes}`;
    }

    function updateTimeZone() {
      const timezoneSelector = document.getElementById("timezone-selector");
      utcOffset = parseInt(timezoneSelector.value);
      localStorage.setItem('utcOffset', utcOffset);
      updateTimestamp();
    }

    function updateTimestamp() {
      const now = new Date();
      const adjustedTime = new Date(now.getTime() + (utcOffset * 60 * 60 * 1000));
      const options = {
        weekday: 'short',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 1,
        hour12: true,
      };
      let formattedDate = adjustedTime.toLocaleString('es-ES', options);
      formattedDate = formattedDate.replace(/(\d{2})\/(\d{2})\/(\d{4})/, '$3-$1-$2');
      formattedDate += ` ${formatUtcOffset(utcOffset)}`;
      document.getElementById("local-time").innerText = formattedDate;

      setTimeout(updateTimestamp, 1000);
    }

    updateTimestamp();
  </script>
</body>
</html>
