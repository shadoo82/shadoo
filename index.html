<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Detalle del Símbolo</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    body {
      background-color: #1a1a1a;
      color: #ffffff;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }
    #local-time {
      text-align: center;
      margin-bottom: 5px;
      color: #cccccc;
      font-size: 16px;
    }
    #current-price {
      text-align: center;
      margin-bottom: 5px;
      color: #00ff00;
      font-size: 18px;
    }
    #stats-timestamp {
      text-align: center;
      margin-bottom: 20px;
      font-size: 16px;
    }
    #stats-timestamp p {
      margin: 2px 0;
      color: #cccccc;
    }
    .container {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .panel {
      flex: 1;
      border: 1px solid #444;
      background-color: #2f2f2f;
      padding: 5px 10px 10px 10px;
      min-width: 300px;
    }
    .title-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      width: 100%;
      text-align: center;
      margin-top: -5px;
    }
    .total-count {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 5px;
      text-align: center;
    }
    .asks-total {
      color: #ff0000;
    }
    .bids-total {
      color: #55ff55;
    }
    .indicator-circle {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    .indicator-circle-start {
      margin-right: 5px;
    }
    .indicator-circle-end {
      margin-left: 5px;
    }
    .circle-red {
      background-color: #ff0000;
    }
    .circle-green {
      background-color: #00ff00;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: #2a2a2a;
      border: 1px solid #444;
      margin-bottom: 10px;
    }
    th, td {
      padding: 4px;
      border: 1px solid #444;
      position: relative;
      cursor: pointer;
      line-height: 1.2;
      font-size: 14px;
    }
    th {
      background-color: #333;
      color: #00ff00;
      font-weight: 500;
      text-align: center;
    }
    td {
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    td span {
      display: inline-block;
      width: 100%;
      text-align: center;
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    td::selection, td span::selection {
      background: rgba(0, 255, 0, 0.3);
    }
    td::-moz-selection, td span::-moz-selection {
      background: rgba(0, 255, 0, 0.3);
    }
    .ask-row { color: #cccccc; }
    .bid-row { color: #cccccc; }
    tr:hover { background-color: #3a3a3a; }
    .highlight-top {
      background-color: rgba(255, 255, 0, 0.2);
      color: #ffffff;
      font-weight: bold;
    }
    .color-transparent {
      background-color: transparent;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-blue {
      background-color: #090ef5;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-blue td {
      color: #ffffff;
    }
    .color-yellow {
      background-color: #e0f30a;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-yellow td {
      color: #000000;
    }
    .color-orange {
      background-color: #f5550f;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-orange td {
      color: #000000;
    }
    .bold-row td {
      font-weight: bold;
    }
    .highlight-red {
      background-color: rgba(249, 12, 12, 0.5);
      transition: background-color 1s ease-out;
    }
    .highlight-red td {
      color: #ffffff;
      font-weight: bold;
    }
    tr.highlight-green {
      background-color: #00ff00;
      transition: background-color 1s ease-out;
    }
    tr.highlight-green td {
      color: #000000;
      font-weight: bold;
    }
    .legend {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-top: 10px;
    }
    .legend-row {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      border-radius: 3px;
      font-size: 14px;
      background-color: #2f2f2f;
      color: #cccccc;
      line-height: 1.2;
    }
    .legend .bid-updated-legend {
      background-color: #00ff00;
      color: #000000;
    }
    .copied {
      background-color: rgba(0, 255, 0, 0.3);
      transition: background-color 0.5s ease;
    }
    .price-cell:hover {
      background-color: rgba(0, 255, 0, 0.1);
      transition: none;
    }
    .highlight-total {
      background-color: #004d00;
      padding: 2px 4px;
      border-radius: 3px;
    }
    .error-message {
      color: #ff5555;
      text-align: center;
      margin: 10px 0;
      font-size: 14px;
    }
    #chart-container {
      width: 100%;
      height: 400px;
      margin-top: 20px;
      background-color: #2f2f2f;
      border: 1px solid #444;
      border-radius: 5px;
    }
    .chart-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      justify-content: center;
      align-items: center;
    }
    .chart-controls button, .chart-controls select {
      background-color: #333;
      color: #ffffff;
      border: 1px solid #444;
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
      border-radius: 3px;
    }
    .chart-controls button:hover, .chart-controls select:hover {
      background-color: #444;
    }
    .select-price-btn {
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      font-size: 16px;
      color: #00ff00;
    }
    .select-price-btn:hover {
      opacity: 0.8;
    }
    .select-circle {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #444;
      cursor: pointer;
    }
    .select  select-circle:hover {
      background-color: #666;
    }
    .selected-row {
      background-color: rgba(0, 255, 0, 0.2);
    }
    .pair-selector {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
      justify-content: flex-start;
      flex-wrap: wrap;
    }
    .pair-selector input, .pair-selector button, .pair-selector select {
      background-color: #333;
      color: #ffffff;
      border: 1px solid #444;
      padding: 5px 10px;
      font-size: 16px;
      border-radius: 3px;
    }
    .pair-selector input {
      width: 150px;
      text-transform: uppercase;
    }
    .pair-selector button:hover, .pair-selector select:hover {
      background-color: #444;
    }
  </style>
</head>
<body>
  <p id="local-time"></p>
  <p id="current-price">Precio actual: Cargando...</p>
  <div id="stats-timestamp">
    <p>Diferencia procesada del libro de órdenes: <span id="diff-orderbook">0</span></p>
    <p>Total de precios procesados: <span id="total-prices">0</span></p>
    <p>Estado del WebSocket: <span id="websocket-status">Conectando...</span></p>
  </div>
  <div id="error-message" class="error-message"></div>

  <div class="pair-selector">
    <input list="pair-options" id="pair-search" placeholder="Buscar par (ej. BTCUSDT)" value="BTCUSDT" />
    <datalist id="pair-options"></datalist>
    <button onclick="autoScaleChart()">Escala automática</button>
    <select id="timeframe-selector" onchange="changeTimeframe()">
      <option value="15m">15m</option>
      <option value="1h" selected>1h</option>
      <option value="4h">4h</option>
      <option value="1d">1d</option>
    </select>
    <button onclick="exportLines()">Exportar/Importar líneas</button>
    <select id="zones-selector" onchange="updateZones()">
      <option value="10">10</option>
      <option value="15" selected>15</option>
      <option value="20">20</option>
    </select>
  </div>
  <div id="chart-container"></div>

  <div class="container">
    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="bids-indicator-start"></span>
        <div class="total-count bids-total" id="bids-total">BIDS - 0 | TOTAL: 0</div>
        <span class="indicator-circle indicator-circle-end" id="bids-indicator-end"></span>
      </div>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Edad</th>
            <th>Precio</th>
            <th>Cant.</th>
            <th>USDT</th>
            <th>% al precio</th>
            <th>Acum. USDT</th>
            <th>Acum. Cant.</th>
            <th>Impactos</th>
            <th>Seleccionar</th>
          </tr>
        </thead>
        <tbody id="bids-body"></tbody>
      </table>
      <div class="legend">
        <div class="legend-row bid-updated-legend">Bid actualizado (Compra, Texto Negro)</div>
        <div class="legend-row" style="background-color: #090ef5; color: #ffffff;">Bids dentro de 0.5% a 1% del markPrice (Texto Blanco)</div>
        <div class="legend-row" style="background-color: #e0f30a; color: #000000;">Bids dentro de 0.1% a 0.5% del markPrice (Texto Negro)</div>
        <div class="legend-row" style="background-color: #f5550f; color: #000000;">Bids dentro de 0.1% del markPrice (Texto Negro)</div>
      </div>
    </div>

    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="asks-indicator-start"></span>
        <div class="total-count asks-total" id="asks-total">ASKS - 0 | TOTAL: 0</div>
        <span class="indicator-circle indicator-circle-end" id="asks-indicator-end"></span>
      </div>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Edad</th>
            <th>Precio</th>
            <th>Cant.</th>
            <th>USDT</th>
            <th>% al precio</th>
            <th>Acum. USDT</th>
            <th>Acum. Cant.</th>
            <th>Impactos</th>
            <th>Seleccionar</th>
          </tr>
        </thead>
        <tbody id="asks-body"></tbody>
      </table>
      <div class="legend">
        <div class="legend-row" style="background-color: rgba(249, 12, 12, 0.5); color: #ffffff;">Ask actualizado (Venta, Texto Blanco)</div>
        <div class="legend-row" style="background-color: #090ef5; color: #ffffff;">Asks dentro de 0.5% a 1% del markPrice (Texto Blanco)</div>
        <div class="legend-row" style="background-color: #e0f30a; color: #000000;">Asks dentro de 0.1% a 0.5% del markPrice (Texto Negro)</div>
        <div class="legend-row" style="background-color: #f5550f; color: #000000;">Asks dentro de 0.1% del markPrice (Texto Negro)</div>
      </div>
    </div>
  </div>

  <script>
    let symbol = "BTCUSDT";
    let currentTimeframe = "1h";
    let tickerWsUrl = `wss://fstream.binance.com/ws/!miniTicker@arr`;
    let depthFuturesWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@depth@100ms`;
    let depthSpotWsUrl = `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@depth@100ms`;
    let klineWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${currentTimeframe}`;
    let klineRestUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${currentTimeframe}&limit=100`;

    let currentPrice = 0;
    let markPrice = 0;
    let asksData = [];
    let bidsData = [];
    let asksProcessed = 0;
    let bidsProcessed = 0;
    let diffOrderbookProcessed = 0;
    let pendingUpdate = false;
    let lastPriceUpdateTime = 0;
    let lastDepthUpdateTime = 0;
    const TABLE_UPDATE_DEBOUNCE_MS = 500;
    const rowColors = new Map();
    const COLOR_DURATION_MS = 5000;
    let selectedPrices = new Map();
    let lastTableUpdate = 0;
    let klineReconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_DELAY_MS = 7000;
    let maxZones = 15;
    let tickerSocket = null;
    let depthFuturesSocket = null;
    let depthSpotSocket = null;
    let klineSocket = null;

    let chart = null;
    let candlestickSeries = null;
    let candlesData = [];
    let lastHoveredPrice = null;
    let markerTimeout = null;
    let allPairs = [];
    let futuresPairs = [];
    let spotPairs = [];

    const utcOffset = -4;

    async function fetchPairs(maxRetries = 3, delayMs = 5000) {
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          console.log(`Intentando obtener pares de Binance (Intento ${attempt}/${maxRetries})...`);
          const futuresResponse = await fetch("https://fapi.binance.com/fapi/v1/exchangeInfo");
          if (!futuresResponse.ok) {
            throw new Error(`Solicitud a la API de futuros falló con estado: ${futuresResponse.status}`);
          }
          const futuresData = await futuresResponse.json();
          futuresPairs = futuresData.symbols
            .filter((s) => s.status === "TRADING" && s.symbol.endsWith("USDT"))
            .map((s) => s.symbol);

          const spotResponse = await fetch("https://api.binance.com/api/v3/exchangeInfo");
          if (!spotResponse.ok) {
            throw new Error(`Solicitud a la API de spot falló con estado: ${spotResponse.status}`);
          }
          const spotData = await spotResponse.json();
          spotPairs = spotData.symbols
            .filter((s) => s.symbol.endsWith("USDT"))
            .map((s) => s.symbol);

          allPairs = [...new Set([...futuresPairs, ...spotPairs])].sort();
          populatePairSelector();
          console.log("Pares obtenidos:", allPairs);
          document.getElementById("error-message").innerText = "";
          return;
        } catch (error) {
          console.error(`Error al obtener los pares (Intento ${attempt}/${maxRetries}):`, error.message);
          const errorMessage = `Error al cargar los pares desde Binance (Intento ${attempt}/${maxRetries}): ${error.message}`;
          document.getElementById("error-message").innerText = errorMessage;

          if (attempt < maxRetries) {
            console.log(`Reintentando en ${delayMs / 1000} segundos...`);
            await new Promise((resolve) => setTimeout(resolve, delayMs));
          } else {
            console.error("No se pudieron obtener los pares después de varios intentos.");
            document.getElementById("error-message").innerText =
              "No se pudieron obtener los pares de Binance después de varios intentos.";
          }
        }
      }
    }

    function populatePairSelector() {
      const pairSelector = document.getElementById("pair-options");
      pairSelector.innerHTML = "";
      allPairs.forEach((pair) => {
        const option = document.createElement("option");
        option.value = pair;
        option.textContent = pair;
        pairSelector.appendChild(option);
      });
      document.getElementById("pair-search").value = symbol;
    }

    function filterPairs() {
      const pairSearch = document.getElementById("pair-search");
      pairSearch.value = pairSearch.value.toUpperCase();
      const searchInput = pairSearch.value.trim();
      const pairSelector = document.getElementById("pair-options");
      pairSelector.innerHTML = "";
      const filteredPairs = allPairs.filter((pair) =>
        pair.toUpperCase().includes(searchInput)
      );
      filteredPairs.forEach((pair) => {
        const option = document.createElement("option");
        option.value = pair;
        option.textContent = pair;
        pairSelector.appendChild(option);
      });
    }

    function changePair() {
      const newSymbol = document.getElementById("pair-search").value.toUpperCase();
      if (newSymbol && newSymbol !== symbol && allPairs.includes(newSymbol)) {
        symbol = newSymbol;
        depthFuturesWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@depth@100ms`;
        depthSpotWsUrl = `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@depth@100ms`;
        klineWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${currentTimeframe}`;
        klineRestUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${currentTimeframe}&limit=100`;

        asksData = [];
        bidsData = [];
        asksProcessed = 0;
        bidsProcessed = 0;
        diffOrderbookProcessed = 0;
        currentPrice = 0;
        markPrice = 0;
        candlesData = [];
        selectedPrices.clear();

        closeAllSockets();
        setupAllSockets();
        loadHistoricalKlines();

        document.getElementById("pair-search").value = symbol;
        document.getElementById("current-price").innerText = `Precio de ${symbol}: Cargando...`;
        document.getElementById("asks-total").innerText = `ASKS - 0 | TOTAL: 0`;
        document.getElementById("bids-total").innerText = `BIDS - 0 | TOTAL: 0`;
        document.getElementById("diff-orderbook").innerText = "0";
        document.getElementById("total-prices").innerText = "0";
      }
    }

    function closeAllSockets() {
      if (tickerSocket) {
        tickerSocket.close();
        tickerSocket = null;
      }
      if (depthFuturesSocket) {
        depthFuturesSocket.close();
        depthFuturesSocket = null;
      }
      if (depthSpotSocket) {
        depthSpotSocket.close();
        depthSpotSocket = null;
      }
      if (klineSocket) {
        klineSocket.close();
        klineSocket = null;
      }
    }

    function setupAllSockets() {
      tickerSocket = setupTickerSocket();
      depthFuturesSocket = setupDepthFuturesSocket();
      setupDepthSpotSocket();
      setupKlineSocket();
    }

    function initializeChart() {
      const chartContainer = document.getElementById("chart-container");
      chart = LightweightCharts.createChart(chartContainer, {
        width: chartContainer.offsetWidth,
        height: 400,
        layout: {
          background: { type: "solid", color: "#2f2f2f" },
          textColor: "#d1d4dc",
        },
        grid: {
          vertLines: { color: "#444" },
          horzLines: { color: "#444" },
        },
        timeScale: {
          timeVisible: true,
          secondsVisible: false,
        },
        rightPriceScale: {
          borderColor: "#444",
        },
        handleScroll: {
          mouseWheel: true,
          pressedMouseMove: true,
          horzTouchDrag: true,
          vertTouchDrag: true,
        },
        handleScale: {
          axisPressedMouseMove: true,
          mouseWheel: true,
          pinch: true,
        },
      });

      candlestickSeries = chart.addCandlestickSeries({
        upColor: "#00ff00",
        downColor: "#ff0000",
        borderVisible: false,
        wickUpColor: "#00ff00",
        wickDownColor: "#ff0000",
      });

      chart.applyOptions({
        priceScale: {
          scaleMargins: { top: 0.1, bottom: 0.1 },
        },
      });

      setupChartInteractions();
    }

    function autoZoomChart() {
$

      if (!chart || !candlesData || candlesData.length === 0) return;

      const timeframe = currentTimeframe;
      let candlesToShow;

      switch (timeframe) {
        case "15m":
          candlesToShow = 8;
          break;
        case "1h":
          candlesToShow = 12;
          break;
        case "4h":
          candlesToShow = 12;
          break;
        case "1d":
          candlesToShow = 7;
          break;
        default:
          candlesToShow = 12;
      }

      const startIndex = Math.max(0, candlesData.length - candlesToShow);
      const visibleCandles = candlesData.slice(startIndex);

      if (visibleCandles.length === 0) return;

      const fromTime = visibleCandles[0].time;
      const toTime = visibleCandles[visibleCandles.length - 1].time;

      chart.timeScale().setVisibleRange({
        from: fromTime,
        to: toTime,
      });

      chart.priceScale().applyOptions({
        autoScale: true,
        scaleMargins: { top: 0.1, bottom: 0.1 },
      });
    }

    function getVisiblePriceRange() {
      if (!candlesData || candlesData.length === 0) return { minPrice: 0, maxPrice: 0 };
      const visibleRange = chart.timeScale().getVisibleRange();
      if (!visibleRange) return { minPrice: 0, maxPrice: 0 };
      const visibleCandles = candlesData.filter(
        (candle) => candle.time >= visibleRange.from && candle.time <= visibleRange.to
      );
      if (visibleCandles.length === 0) return { minPrice: 0, maxPrice: 0 };
      const minPrice = Math.min(...visibleCandles.map((candle) => candle.low));
      const maxPrice = Math.max(...visibleCandles.map((candle) => candle.high));
      return { minPrice, maxPrice };
    }

    function setupChartInteractions() {
      chart.subscribeCrosshairMove((param) => {
        if (!param || !param.point) return;
        const y = param.point.y;
        const chartContainer = document.getElementById("chart-container");
        const containerHeight = chartContainer.offsetHeight;
        const scaleMargins = { top: 0.1, bottom: 0.1 };
        const effectiveHeight = containerHeight * (1 - scaleMargins.top - scaleMargins.bottom);
        const heightOffset = containerHeight * scaleMargins.top;
        const adjustedY = y - heightOffset;
        if (adjustedY < 0 || adjustedY > effectiveHeight) return;
        const { minPrice, maxPrice } = getVisiblePriceRange();
        const priceRangeLength = maxPrice - minPrice;
        if (priceRangeLength <= 0) return;
        const pricePerPixel = priceRangeLength / effectiveHeight;
        const price = maxPrice - adjustedY * pricePerPixel;
        if (isNaN(price)) return;

        let closestPrice = null;
        let closestDistance = Infinity;
        let closestLine = null;

        selectedPrices.forEach((lineData, selectedPrice) => {
          const distance = Math.abs(selectedPrice - price);
          if (distance < closestDistance) {
            closestDistance = distance;
            closestPrice = selectedPrice;
            closestLine = lineData;
          }
        });

        const threshold = priceRangeLength * 0.03;
        if (closestDistance < threshold) {
          lastHoveredPrice = closestPrice;
          if (closestLine && !closestLine.marker) {
            closestLine.marker = closestLine.series.createPriceLine({
              price: closestPrice,
              color: closestLine.isAsk ? "#ff0000" : "#00ff00",
              lineWidth: 1,
              lineStyle: LightweightCharts.LineStyle.Dashed,
              title: "✖ Cerrar",
            });
          }

          if (markerTimeout) {
            clearTimeout(markerTimeout);
            markerTimeout = null;
          }

          markerTimeout = setTimeout(() => {
            if (lastHoveredPrice === closestPrice) {
              if (closestLine.marker) {
                closestLine.series.removePriceLine(closestLine.marker);
                closestLine.marker = null;
                lastHoveredPrice = null;
              }
            }
          }, 2000);
        } else {
          if (!markerTimeout) {
            markerTimeout = setTimeout(() => {
              selectedPrices.forEach((lineData, priceKey) => {
                if (lineData.marker && priceKey === lastHoveredPrice) {
                  lineData.series.removePriceLine(lineData.marker);
                  lineData.marker = null;
                  lastHoveredPrice = null;
                }
              });
            }, 2000);
          }
        }
      });

      chart.subscribeClick((param) => {
        if (!param || !param.point) return;
        const y = param.point.y;
        const chartContainer = document.getElementById("chart-container");
        const containerHeight = chartContainer.offsetHeight;
        const scaleMargins = { top: 0.1, bottom: 0.1 };
        const effectiveHeight = containerHeight * (1 - scaleMargins.top - scaleMargins.bottom);
        const heightOffset = containerHeight * scaleMargins.top;
        const adjustedY = y - heightOffset;
        if (adjustedY < 0 || adjustedY > effectiveHeight) return;
        const { minPrice, maxPrice } = getVisiblePriceRange();
        const priceRangeLength = maxPrice - minPrice;
        if (priceRangeLength <= 0) return;
        const pricePerPixel = priceRangeLength / effectiveHeight;
        const price = maxPrice - adjustedY * pricePerPixel;
        if (isNaN(price)) return;

        let closestPrice = null;
        let closestDistance = Infinity;

        if (lastHoveredPrice !== null && selectedPrices.has(lastHoveredPrice)) {
          closestPrice = lastHoveredPrice;
          closestDistance = 0;
        } else {
          selectedPrices.forEach((selectedPrice) => {
            const distance = Math.abs(selectedPrice - price);
            if (distance < closestDistance) {
              closestDistance = distance;
              closestPrice = selectedPrice;
            }
          });
        }

        const threshold = priceRangeLength * 0.03;
        if (closestDistance < threshold && closestPrice !== null) {
          drawSelectedPriceLine(closestPrice, null, false);
          updateTableRowsAfterDeselect(closestPrice);
          lastHoveredPrice = null;
          if (markerTimeout) {
            clearTimeout(markerTimeout);
            markerTimeout = null;
          }
          ensureChartVisibility();
        }
      });
    }

    function updateTableRowsAfterDeselect(price) {
      const tableBodies = ["asks-body", "bids-body"];
      tableBodies.forEach((tableId) => {
        const tableBody = document.getElementById(tableId);
        Array.from(tableBody.children).forEach((row) => {
          const rowPriceCell = row.cells[2];
          if (rowPriceCell) {
            const rowPrice = parseFloat(rowPriceCell.textContent);
            if (!isNaN(rowPrice) && rowPrice === price) {
              row.classList.remove("selected-row");
              updateSelectButton(row, price);
            }
          }
        });
      });
    }

    function ensureChartVisibility() {
      if (chart && candlestickSeries && candlesData.length > 0) {
        candlestickSeries.setData(candlesData);
        autoZoomChart();
      }
    }

    function saveHistoricalKlines() {
      const key = `${symbol}_${currentTimeframe}_klines`;
      try {
        // Validar los datos antes de guardarlos
        const validCandles = candlesData.filter(candle =>
          candle.time && !isNaN(candle.open) && !isNaN(candle.high) &&
          !isNaN(candle.low) && !isNaN(candle.close)
        );
        if (validCandles.length > 0) {
          localStorage.setItem(key, JSON.stringify(validCandles));
        }
      } catch (error) {
        console.error("Error al guardar velas históricas en localStorage:", error);
        document.getElementById("error-message").innerText = "Error al guardar datos históricos en almacenamiento local: " + error.message;
      }
    }

    function loadHistoricalKlinesFromStorage() {
      const key = `${symbol}_${currentTimeframe}_klines`;
      const savedData = localStorage.getItem(key);
      if (savedData) {
        try {
          const parsedData = JSON.parse(savedData);
          // Validar cada vela cargada
          const validCandles = parsedData.filter(candle =>
            candle.time && !isNaN(candle.open) && !isNaN(candle.high) &&
            !isNaN(candle.low) && !isNaN(candle.close)
          );
          if (validCandles.length > 0) {
            candlesData = validCandles;
            if (candlestickSeries) {
              candlestickSeries.setData(candlesData);
              autoZoomChart();
            }
            return true;
          }
          console.warn("Datos de velas en localStorage no válidos, intentando carga desde API...");
          return false;
        } catch (error) {
          console.error("Error al parsear velas históricas desde localStorage:", error);
          document.getElementById("error-message").innerText = "Error al cargar datos históricos desde almacenamiento local: " + error.message;
          return false;
        }
      }
      return false;
    }

    async function loadHistoricalKlines(maxRetries = 3, delayMs = 5000) {
      // Intentar cargar desde localStorage primero
      if (loadHistoricalKlinesFromStorage()) {
        console.log("Velas cargadas desde localStorage exitosamente.");
        return;
      }

      // Si no hay datos en localStorage, intentar cargar desde la API
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          console.log(`Intentando cargar velas históricas desde API (Intento ${attempt}/${maxRetries})...`);
          const response = await fetch(klineRestUrl);
          if (!response.ok) {
            throw new Error(`Error HTTP! Estado: ${response.status} - ${response.statusText}`);
          }
          const data = await response.json();
          if (!Array.isArray(data)) {
            throw new Error("Formato de datos de velas inválido: no es un arreglo");
          }
          if (data.length === 0) {
            throw new Error("No se recibieron datos de velas de la API");
          }

          // Procesar los datos recibidos
          candlesData = data.map((kline) => {
            const time = Math.floor(kline[0] / 1000);
            const open = parseFloat(kline[1]);
            const high = parseFloat(kline[2]);
            const low = parseFloat(kline[3]);
            const close = parseFloat(kline[4]);
            if (isNaN(time) || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
              throw new Error("Valores de vela inválidos en los datos recibidos");
            }
            return { time, open, high, low, close };
          });

          if (candlestickSeries && candlesData.length > 0) {
            candlestickSeries.setData(candlesData);
            autoZoomChart();
            saveHistoricalKlines();
            console.log("Velas históricas cargadas exitosamente desde la API.");
            document.getElementById("error-message").innerText = "";
            return;
          } else {
            throw new Error("No se pudieron procesar los datos de las velas");
          }
        } catch (error) {
          console.error(`Error al cargar velas históricas (Intento ${attempt}/${maxRetries}):`, error);
          const errorMessage = `Error al cargar velas históricas (Intento ${attempt}/${maxRetries}): ${error.message}`;
          document.getElementById("error-message").innerText = errorMessage;

          if (attempt < maxRetries) {
            console.log(`Reintentando en ${delayMs / 1000} segundos...`);
            await new Promise((resolve) => setTimeout(resolve, delayMs));
          } else {
            console.error("No se pudieron cargar las velas históricas después de varios intentos.");
            document.getElementById("error-message").innerText =
              "No se pudieron cargar las velas históricas después de varios intentos. Por favor, intenta con otro par o temporalidad.";
          }
        }
      }
    }

    let isChangingTimeframe = false;
    let lastCandleTime = null;

    function setupKlineSocket() {
      if (klineSocket) {
        klineSocket.close();
        klineSocket = null;
      }
      klineSocket = new WebSocket(klineWsUrl);
      klineSocket.onopen = () => {
        klineReconnectAttempts = 0;
        updateWebSocketStatus();
        console.log("WebSocket de Kline abierto para la temporalidad:", currentTimeframe);
        document.getElementById("error-message").innerText = "";
      };
      klineSocket.onclose = (event) => {
        updateWebSocketStatus();
        if (!isChangingTimeframe && klineReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          klineReconnectAttempts++;
          console.log(`WebSocket de Kline cerrado. Reconectando (intento ${klineReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
          setTimeout(() => {
            setupKlineSocket();
          }, RECONNECT_DELAY_MS * klineReconnectAttempts);
        } else if (klineReconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
          document.getElementById("error-message").innerText = "Se alcanzó el máximo de intentos de reconexión para el WebSocket de Kline.";
        }
      };
      klineSocket.onerror = (error) => {
        console.error("Error en el WebSocket de Kline:", error);
        updateWebSocketStatus();
        document.getElementById("error-message").innerText = "Ocurrió un error en el WebSocket de Kline: " + (error.message || "Desconocido");
      };
      klineSocket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (!data || !data.k) {
            throw new Error("Formato de datos de kline inválido");
          }
          const kline = data.k;
          const time = Math.floor(kline.t / 1000);
          const open = parseFloat(kline.o);
          const high = parseFloat(kline.h);
          const low = parseFloat(kline.l);
          const close = parseFloat(kline.c);

          if (isNaN(time) || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
            throw new Error("Valores de kline inválidos");
          }

          const candleData = { time, open, high, low, close };
          if (lastCandleTime && lastCandleTime === time) {
            const lastCandleIndex = candlesData.findIndex((c) => c.time === time);
            if (lastCandleIndex !== -1) {
              candlesData[lastCandleIndex] = candleData;
              candlestickSeries.update(candleData);
            }
          } else {
            candlesData.push(candleData);
            if (candlesData.length > 1000) {
              candlesData.shift();
            }
            candlestickSeries.setData(candlesData);
            chart.timeScale().scrollToRealTime();
            lastCandleTime = time;
            saveHistoricalKlines();
          }
        } catch (error) {
          console.error("Error al procesar mensaje de kline:", error);
          document.getElementById("error-message").innerText = "Error al procesar datos de kline: " + error.message;
        }
      };
    }

    function changeTimeframe() {
      if (isChangingTimeframe) return;
      isChangingTimeframe = true;

      const newTimeframe = document.getElementById("timeframe-selector").value;
      if (newTimeframe === currentTimeframe) {
        isChangingTimeframe = false;
        return;
      }

      console.log(`Cambiando temporalidad de ${currentTimeframe} a ${newTimeframe}`);
      currentTimeframe = newTimeframe;
      klineWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${currentTimeframe}`;
      klineRestUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${currentTimeframe}&limit=100`;

      if (klineSocket) {
        klineSocket.onclose = null;
        klineSocket.close();
        klineSocket = null;
      }

      candlesData = [];
      lastCandleTime = null;

      loadHistoricalKlines()
        .then(() => {
          setupKlineSocket();
          isChangingTimeframe = false;
          console.log("Temporalidad cambiada exitosamente a", currentTimeframe);
        })
        .catch((error) => {
          console.error("Error al cambiar temporalidad:", error);
          isChangingTimeframe = false;
          document.getElementById("error-message").innerText = "Error al cambiar temporalidad: " + error.message;
        });
    }

    function autoScaleChart() {
      if (chart) {
        chart.timeScale().fitContent();
        chart.priceScale().applyOptions({
          autoScale: true,
        });
      }
    }

    function exportLines() {
      const linesData = Array.from(selectedPrices.entries()).map(([price, line]) => ({
        price: price,
        color: line.isAsk ? "#ff0000" : "#00ff00",
        isAsk: line.isAsk,
      }));
      const blob = new Blob([JSON.stringify(linesData)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "selected_lines.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function updateZones() {
      maxZones = parseInt(document.getElementById("zones-selector").value);
      scheduleTableUpdate();
    }

    function initializeApp() {
      fetchPairs().then(() => {
        initializeChart();
        if (chart && candlestickSeries) {
          loadHistoricalKlines()
            .then(() => {
              setupAllSockets();
              loadSelectedPrices();
              setupEventListeners();
              updateTimestamp();
              setInterval(updateTimestamp, 1000);

              const pairSearch = document.getElementById("pair-search");
              pairSearch.addEventListener("input", filterPairs);
              pairSearch.addEventListener("change", changePair);
              pairSearch.addEventListener("click", () => {
                pairSearch.value = "";
              });
            })
            .catch((error) => {
              console.error("Error al inicializar la aplicación:", error);
              document.getElementById("error-message").innerText = "Error al inicializar la aplicación: " + error.message;
            });
        }
      });
    }

    function waitForLightweightCharts() {
      if (typeof LightweightCharts !== "undefined") {
        initializeApp();
      } else {
        setTimeout(waitForLightweightCharts, 100);
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      waitForLightweightCharts();
    });

    function saveSelectedPrices() {
      const prices = Array.from(selectedPrices.entries()).map(([price, line]) => ({
        price: price,
        isAsk: line.isAsk,
      }));
      localStorage.setItem("selectedPrices", JSON.stringify(prices));
    }

    function loadSelectedPrices() {
      const savedPrices = localStorage.getItem("selectedPrices");
      if (savedPrices) {
        try {
          const prices = JSON.parse(savedPrices);
          prices.forEach((item) => {
            const priceNum = parseFloat(item.price);
            const isAsk = item.isAsk;
            if (!isNaN(priceNum) && !selectedPrices.has(priceNum)) {
              drawSelectedPriceLine(priceNum, null, isAsk);
            }
          });
        } catch (error) {
          console.error("Error al cargar precios seleccionados:", error);
        }
      }
    }

    function drawSelectedPriceLine(price, row, isAsk) {
      if (selectedPrices.has(price)) {
        const line = selectedPrices.get(price);
        if (line.marker) {
          line.series.removePriceLine(line.marker);
        }
        chart.removeSeries(line.series);
        selectedPrices.delete(price);
        if (row) {
          row.classList.remove("selected-row");
          updateSelectButton(row, price);
        }
        saveSelectedPrices();
        ensureChartVisibility();
        return;
      }

      const lineColor = isAsk ? "#ff0000" : "#00ff00";
      const lineSeries = chart.addLineSeries({
        color: lineColor,
        lineWidth: 1,
        priceLineVisible: false,
        lastValueVisible: false,
      });

      const now = Math.floor(Date.now() / 1000);
      lineSeries.setData([
        { time: now - 86400, value: price },
        { time: now, value: price },
      ]);

      lineSeries.createPriceLine({
        price: price,
        color: lineColor,
        lineWidth: 1,
        lineStyle: LightweightCharts.LineStyle.Solid,
        title: `Precio: ${formatPrice(price)}`,
      });

      selectedPrices.set(price, { series: lineSeries, price: price, isAsk: isAsk, marker: null });
      if (row) {
        row.classList.add("selected-row");
        updateSelectButton(row, price);
      }
      saveSelectedPrices();
      ensureChartVisibility();
    }

    function updateSelectButton(row, price) {
      const selectCell = row.querySelector("td:last-child");
      if (selectCell) {
        if (selectedPrices.has(price)) {
          selectCell.innerHTML = `<button class="select-price-btn" data-price="${price}">📍</button>`;
        } else {
          selectCell.innerHTML = `<span class="select-circle" data-price="${price}"></span>`;
        }
      }
    }

    function redrawSelectedLines() {
      const pricesToRedraw = Array.from(selectedPrices.entries()).map(([price, lineData]) => ({
        price: price,
        isAsk: lineData.isAsk,
      }));
      selectedPrices.forEach((value, price) => {
        if (value.series) {
          if (value.marker) {
            value.series.removePriceLine(value.marker);
          }
          chart.removeSeries(value.series);
        }
      });
      selectedPrices.clear();
      pricesToRedraw.forEach((item) => {
        drawSelectedPriceLine(item.price, null, item.isAsk);
      });
      ensureChartVisibility();
    }

    window.addEventListener("resize", () => {
      if (chart) {
        const chartContainer = document.getElementById("chart-container");
        chart.resize(chartContainer.offsetWidth, 400);
        redrawSelectedLines();
      }
    });

    function setupEventListeners() {
      const tableBodies = document.querySelectorAll("#asks-body, #bids-body");
      tableBodies.forEach((tableBody) => {
        const isAsk = tableBody.id === "asks-body";
        tableBody.addEventListener("click", (event) => {
          const selectBtn = event.target.closest(".select-price-btn, .select-circle");
          if (selectBtn) {
            event.stopPropagation();
            event.preventDefault();
            const price = parseFloat(selectBtn.dataset.price);
            const row = selectBtn.closest("tr");
            if (row && !isNaN(price)) {
              drawSelectedPriceLine(price, row, isAsk);
            }
          }
        });

        tableBody.addEventListener("click", (event) => {
          const priceCell = event.target.closest(".price-cell");
          if (priceCell) {
            event.stopPropagation();
            event.preventDefault();
            copyPriceCell(priceCell);
          }
        });
      });
    }

    function updateWebSocketStatus() {
      const statuses = [];
      if (tickerSocket && tickerSocket.readyState === WebSocket.OPEN) statuses.push("ticker");
      if (depthFuturesSocket && depthFuturesSocket.readyState === WebSocket.OPEN) statuses.push("depthFutures");
      if (depthSpotSocket && depthSpotSocket.readyState === WebSocket.OPEN) statuses.push("depthSpot");
      if (klineSocket && klineSocket.readyState === WebSocket.OPEN) statuses.push("kline");

      if (statuses.length === 4) {
        document.getElementById("websocket-status").innerText = "Conectado";
      } else if (statuses.length > 0) {
        document.getElementById("websocket-status").innerText = `Parcialmente conectado (${statuses.join(", ")})`;
      } else {
        document.getElementById("websocket-status").innerText = "Desconectado";
      }
    }

    function setupTickerSocket() {
      const socket = new WebSocket(tickerWsUrl);
      socket.onopen = () => {
        console.log("WebSocket de Ticker abierto");
        updateWebSocketStatus();
      };
      socket.onclose = () => {
        console.log("WebSocket de Ticker cerrado");
        updateWebSocketStatus();
        setTimeout(() => {
          tickerSocket = setupTickerSocket();
        }, RECONNECT_DELAY_MS);
      };
      socket.onerror = (error) => {
        console.error("Error en el WebSocket de Ticker:", error);
        updateWebSocketStatus();
        document.getElementById("error-message").innerText = "Ocurrió un error en el WebSocket de Ticker.";
      };
      socket.onmessage = (event) => {
        try {
          const startTime = performance.now();
          const data = JSON.parse(event.data);
          if (!Array.isArray(data)) {
            throw new Error("Formato de datos de ticker inválido");
          }
          const symbolData = data.find((item) => item && item.s === symbol.toUpperCase());
          if (symbolData && symbolData.c) {
            const newPrice = parseFloat(symbolData.c);
            if (isNaN(newPrice)) {
              throw new Error("Valor de precio inválido en datos de ticker");
            }
            currentPrice = newPrice;
            markPrice = parseFloat(symbolData.p) || currentPrice;
            document.getElementById("current-price").innerText = `Precio de ${symbol}: ${formatPrice(currentPrice)}`;
            lastPriceUpdateTime = startTime;
            scheduleTableUpdate();
          }
        } catch (error) {
          console.error("Error al procesar mensaje de ticker:", error);
          document.getElementById("error-message").innerText = "Error al procesar datos de ticker: " + error.message;
        }
      };
      return socket;
    }

    function setupDepthFuturesSocket() {
      if (!futuresPairs.includes(symbol)) {
        console.warn(`El par ${symbol} no está disponible en futuros.`);
        document.getElementById("error-message").innerText = `El par ${symbol} no está disponible en futuros. Intenta con otro par.`;
        return null;
      }
      const socket = new WebSocket(depthFuturesWsUrl);
      socket.onopen = () => {
        console.log("WebSocket de Futuros abierto");
        updateWebSocketStatus();
        document.getElementById("error-message").innerText = "";
      };
      socket.onclose = () => {
        console.log("WebSocket de Futuros cerrado");
        updateWebSocketStatus();
        setTimeout(() => {
          depthFuturesSocket = setupDepthFuturesSocket();
        }, RECONNECT_DELAY_MS);
      };
      socket.onerror = (error) => {
        console.error("Error en el WebSocket de Futuros:", error);
        updateWebSocketStatus();
        document.getElementById("error-message").innerText = `Error en el WebSocket de Futuros: ${error.message || 'Desconocido'}. Reintentando...`;
      };
      socket.onmessage = (event) => {
        try {
          const startTime = performance.now();
          const data = JSON.parse(event.data);
          if (!data || (!data.a && !data.b)) {
            throw new Error("Formato de datos de profundidad inválido");
          }
          const now = Date.now();

          if (data.a) {
            asksData = updateOrders(asksData, data.a, now, true);
            asksProcessed += data.a.length;
          }
          if (data.b) {
            bidsData = updateOrders(bidsData, data.b, now, false);
            bidsProcessed += data.b.length;
          }

          processDepthData();
        } catch (error) {
          console.error("Error al procesar mensaje de profundidad de futuros:", error);
          document.getElementById("error-message").innerText = "Error al procesar datos de profundidad de futuros: " + error.message;
        }
      };
      return socket;
    }

    function setupDepthSpotSocket() {
      if (!spotPairs.includes(symbol)) {
        console.warn(`El par ${symbol} no está disponible en spot.`);
        return;
      }
      depthSpotSocket = new WebSocket(depthSpotWsUrl);
      depthSpotSocket.onopen = () => {
        console.log("WebSocket de Spot abierto");
        updateWebSocketStatus();
      };
      depthSpotSocket.onclose = () => {
        console.log("WebSocket de Spot cerrado");
        updateWebSocketStatus();
        setTimeout(() => {
          setupDepthSpotSocket();
        }, RECONNECT_DELAY_MS);
      };
      depthSpotSocket.onerror = (error) => {
        console.error("Error en el WebSocket de Spot:", error);
        updateWebSocketStatus();
        document.getElementById("error-message").innerText = "Ocurrió un error en el WebSocket de Spot.";
      };
      depthSpotSocket.onmessage = (event) => {
        try {
          const startTime = performance.now();
          const data = JSON.parse(event.data);
          if (!data || (!data.a && !data.b)) {
            throw new Error("Formato de datos de profundidad inválido");
          }
          const now = Date.now();

          if (data.a) {
            asksData = updateOrders(asksData, data.a, now, true);
            asksProcessed += data.a.length;
          }
          if (data.b) {
            bidsData = updateOrders(bidsData, data.b, now, false);
            bidsProcessed += data.b.length;
          }

          processDepthData();
        } catch (error) {
          console.error("Error al procesar mensaje de profundidad de spot:", error);
          document.getElementById("error-message").innerText = "Error al procesar datos de profundidad de spot: " + error.message;
        }
      };
    }

    function processDepthData() {
      if (currentPrice > 0) {
        asksData = asksData.filter((item) => {
          const diff = Math.abs((item.price - currentPrice) / currentPrice) * 100;
          return diff <= 10;
        });
        bidsData = bidsData.filter((item) => {
          const diff = Math.abs((item.price - currentPrice) / currentPrice) * 100;
          return diff <= 10;
        });
      }

      asksData.sort((a, b) => b.usdt - a.usdt);
      bidsData.sort((a, b) => b.usdt - a.usdt);

      asksData = asksData.slice(0, maxZones);
      bidsData = bidsData.slice(0, maxZones);

      diffOrderbookProcessed = Math.abs(asksProcessed - bidsProcessed);

      document.getElementById("diff-orderbook").innerText = diffOrderbookProcessed.toLocaleString();
      document.getElementById("asks-total").innerText = `ASKS - ${asksData.length} | TOTAL: ${asksProcessed.toLocaleString()}`;
      document.getElementById("bids-total").innerText = `BIDS - ${bidsData.length} | TOTAL: ${bidsProcessed.toLocaleString()}`;
      const totalPrices = asksProcessed + bidsProcessed;
      document.getElementById("total-prices").innerText = totalPrices.toLocaleString();

      if (totalPrices > 250000) {
        document.getElementById("total-prices").classList.add("highlight-total");
      } else {
        document.getElementById("total-prices").classList.remove("highlight-total");
      }

      const asksIndicatorStart = document.getElementById("asks-indicator-start");
      const asksIndicatorEnd = document.getElementById("asks-indicator-end");
      const bidsIndicatorStart = document.getElementById("bids-indicator-start");
      const bidsIndicatorEnd = document.getElementById("bids-indicator-end");
      asksIndicatorStart.classList.remove("circle-red", "circle-green");
      asksIndicatorEnd.classList.remove("circle-red", "circle-green");
      bidsIndicatorStart.classList.remove("circle-red", "circle-green");
      bidsIndicatorEnd.classList.remove("circle-red", "circle-green");
      if (asksProcessed > bidsProcessed) {
        asksIndicatorStart.classList.add("circle-red");
        asksIndicatorEnd.classList.add("circle-red");
      } else if (bidsProcessed > asksProcessed) {
        bidsIndicatorStart.classList.add("circle-green");
        bidsIndicatorEnd.classList.add("circle-green");
      }

      scheduleTableUpdate();
    }

    function scheduleTableUpdate() {
      if (!pendingUpdate) {
        pendingUpdate = true;
        const now = Date.now();
        if (now - lastTableUpdate < TABLE_UPDATE_DEBOUNCE_MS) {
          setTimeout(() => {
            pendingUpdate = false;
            scheduleTableUpdate();
          }, TABLE_UPDATE_DEBOUNCE_MS - (now - lastTableUpdate));
          return;
        }
        requestAnimationFrame(() => {
          updateTables();
          lastTableUpdate = Date.now();
          pendingUpdate = false;
        });
      }
    }

    function updateOrders(existingOrders, newOrders, now, isAsk) {
      const ordersMap = new Map(existingOrders.map((o) => [o.price, o]));

      newOrders.forEach(([p, q]) => {
        const price = parseFloat(p);
        const qty = parseFloat(q);
        if (isNaN(price) || isNaN(qty)) {
          console.warn(`Precio o cantidad inválida: price=${p}, qty=${q}`);
          return;
        }
        const usdt = price * qty;

        if (qty <= 0) {
          ordersMap.delete(price);
          rowColors.delete(price);
        } else {
          if (ordersMap.has(price)) {
            const existing = ordersMap.get(price);
            const previousHits = existing.hits || 0;
            existing.qty = qty;
            existing.usdt = usdt;
            existing.lastUpdated = now;
            existing.hits = previousHits + 1;
            existing.colorAssignedTime = now;
          } else {
            ordersMap.set(price, {
              price,
              qty,
              usdt,
              lastUpdated: now,
              colorAssignedTime: now,
              hits: 1,
            });
          }
        }
      });

      return Array.from(ordersMap.values());
    }

    function getColorClass(price, markPrice, isAsk, colorAssignedTime, now) {
      if (!markPrice || markPrice === 0) return "color-transparent";
      const diff = ((price - markPrice) / markPrice) * 100;
      const absDiff = Math.abs(diff);
      const colorAge = now - colorAssignedTime;

      if (colorAge > COLOR_DURATION_MS) {
        return "color-transparent";
      }

      if (absDiff <= 0.1) {
        return "color-orange";
      } else if (absDiff > 0.1 && absDiff <= 0.5) {
        return "color-yellow";
      } else if (absDiff > 0.5 && absDiff <= 1) {
        return "color-blue";
      }
      return "color-transparent";
    }

    function updateTables() {
      updateTable("asks-body", asksData, markPrice, true);
      updateTable("bids-body", bidsData, markPrice, false);
    }

    function updateTable(tableId, data, markPrice, isAsk) {
      const tableBody = document.getElementById(tableId);
      const now = Date.now();

      const existingRows = new Map();
      Array.from(tableBody.children).forEach((row) => {
        const priceCell = row.cells[2];
        if (priceCell) {
          const price = parseFloat(priceCell.textContent);
          if (!isNaN(price)) {
            existingRows.set(price, row);
          }
        }
      });

      let accUsdt = 0;
      let accQty = 0;

      const fragment = document.createDocumentFragment();
      data.forEach((item, idx) => {
        const ageTime = formatAge(now - item.lastUpdated);
        const pct = markPrice ? (((item.price - markPrice) / markPrice) * 100).toFixed(3) + "%" : "---";

        accUsdt += item.usdt;
        accQty += item.qty;

        let row = existingRows.get(item.price);
        if (!row) {
          row = document.createElement("tr");
          row.className = isAsk ? "ask-row" : "bid-row";
        }

        if (selectedPrices.has(item.price)) {
          row.classList.add("selected-row");
        } else {
          row.classList.remove("selected-row");
        }

        if (idx < 4) {
          row.classList.add("highlight-top");
        } else {
          row.classList.remove("highlight-top");
        }

        const newColorClass = getColorClass(item.price, markPrice, isAsk, item.colorAssignedTime || now, now);
        row.classList.remove("color-transparent", "color-blue", "color-yellow", "color-orange");
        row.classList.add(newColorClass);
        rowColors.set(item.price, newColorClass);

        if (newColorClass !== "color-transparent") {
          row.classList.add("bold-row");
        } else {
          row.classList.remove("bold-row");
        }

        const highlightDuration = 1000;
        const timeSinceUpdate = now - item.lastUpdated;
        if (timeSinceUpdate <= highlightDuration && item.hits > 1) {
          row.classList.add(isAsk ? "highlight-red" : "highlight-green");
        } else {
          row.classList.remove("highlight-red", "highlight-green");
        }

        row.innerHTML = `
          <td>${idx + 1}</td>
          <td>${ageTime}</td>
          <td class="price-cell">${formatPrice(item.price)}</td>
          <td>${formatQty(item.qty)}</td>
          <td>${formatUsdt(item.usdt)}</td>
          <td>${pct}</td>
          <td>${formatUsdt(accUsdt)}</td>
          <td>${formatQty(accQty)}</td>
          <td>${item.hits || 1}</td>
          <td>${
            selectedPrices.has(item.price)
              ? `<button class="select-price-btn" data-price="${item.price}">📍</button>`
              : `<span class="select-circle" data-price="${item.price}"></span>`
          }</td>
        `;
        fragment.appendChild(row);
        existingRows.delete(item.price);
      });

      existingRows.forEach((row) => row.remove());
      tableBody.appendChild(fragment);
    }

    function copyPriceCell(cell) {
      const priceText = cell.textContent.trim();
      navigator.clipboard
        .writeText(priceText)
        .then(() => {
          cell.classList.add("copied");
        })
        .catch((err) => {
          console.error("Error al copiar precio:", err);
        });
    }

    function formatPrice(value) {
      if (isNaN(value) || value === 0) return "0.00";
      return parseFloat(value).toFixed(2);
    }

    function formatQty(value) {
      if (isNaN(value) || value === 0) return "0";
      if (value >= 1_000_000_000) return (value / 1_000_000_000).toFixed(2) + "b";
      if (value >= 1_000_000) return (value / 1_000_000).toFixed(2) + "m";
      if (value >= 1_000) return (value / 1_000).toFixed(2) + "k";
      if (value < 0.001) return value.toFixed(6);
      return parseFloat(value).toFixed(4);
    }

    function formatUsdt(value) {
      if (isNaN(value) || value === 0) return "0.00";
      if (value >= 1_000_000_000) return (value / 1_000_000_000).toFixed(2) + "b";
      if (value >= 1_000_000) return (value / 1_000_000).toFixed(2) + "m";
      if (value >= 1_000) return (value / 1_000).toFixed(2) + "k";
      if (value < 0.01) return value.toFixed(4);
      return parseFloat(value).toFixed(2);
    }

    function formatAge(ms) {
      const seconds = Math.floor(ms / 1000);
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m`;
      const hours = Math.floor(minutes / 60);
      return `${hours}h`;
    }

    function formatUtcOffset(offset) {
      const sign = offset >= 0 ? "+" : "-";
      const absOffset = Math.abs(offset);
      const hours = Math.floor(absOffset).toString().padStart(2, "0");
      const minutes = ((absOffset % 1) * 60).toString().padStart(2, "0");
      return `UTC${sign}${hours}:${minutes}`;
    }

    function updateTimestamp() {
      const now = new Date();
      now.setUTCHours(now.getUTCHours() + utcOffset);
      const options = {
        weekday: "short",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        fractionalSecondDigits: 1,
        hour12: true,
      };
      let formattedDate = now.toLocaleString("en-US", options);
      formattedDate = formattedDate.replace(/(\d{2})\/(\d{2})\/(\d{4})/, "$3-$1-$2");
      formattedDate += ` ${formatUtcOffset(utcOffset)}`;
      document.getElementById("local-time").innerText = formattedDate;
    }
  </script>
</body>
</html>
