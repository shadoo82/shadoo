<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Detalle del SÃ­mbolo</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    body {
      background-color: #1a1a1a;
      color: #ffffff;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }
    #local-time {
      text-align: center;
      margin-bottom: 5px;
      color: #cccccc;
      font-size: 14px;
    }
    #current-price {
      text-align: center;
      margin-bottom: 5px;
      color: #00ff00;
      font-size: 16px;
    }
    #stats-timestamp {
      text-align: center;
      margin-bottom: 20px;
      font-size: 14px;
    }
    #stats-timestamp p {
      margin: 2px 0;
      color: #cccccc;
    }
    .container {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .panel {
      flex: 1;
      border: 1px solid #444;
      background-color: #2f2f2f;
      padding: 5px 10px 10px 10px;
      min-width: 300px;
    }
    .title-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      width: 100%;
      text-align: center;
      margin-top: -5px;
    }
    .total-count {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 5px;
      text-align: center;
    }
    .asks-total {
      color: #ff0000;
    }
    .bids-total {
      color: #55ff55;
    }
    .indicator-circle {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    .indicator-circle-start {
      margin-right: 5px;
    }
    .indicator-circle-end {
      margin-left: 5px;
    }
    .circle-red {
      background-color: #ff0000 !important;
    }
    .circle-green {
      background-color: #00ff00 !important;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: #2a2a2a;
      border: 1px solid #444;
      margin-bottom: 10px;
      font-size: 10px;
    }
    th,
    td {
      padding: 4px;
      border: 1px solid #444;
      position: relative;
      cursor: pointer;
      line-height: 1.2;
      font-size: 10px;
    }
    th {
      background-color: #333;
      color: #00ff00;
      font-weight: 500;
      text-align: center;
    }
    td {
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    td span {
      display: inline-block;
      width: 100%;
      text-align: center;
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    td::selection,
    td span::selection {
      background: rgba(0, 255, 0, 0.3);
    }
    td::-moz-selection,
    td span::-moz-selection {
      background: rgba(0, 255, 0, 0.3);
    }
    .ask-row {
      color: #cccccc;
    }
    .bid-row {
      color: #cccccc;
    }
    tr:hover {
      background-color: #3a3a3a;
    }
    .highlight-top {
      background-color: rgba(255, 255, 0, 0.2);
      color: #ffffff;
      font-weight: bold;
    }
    .color-transparent {
      background-color: transparent;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-blue {
      background-color: #090ef5;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-blue td {
      color: #ffffff;
    }
    .color-yellow {
      background-color: #e0f30a;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-yellow td {
      color: #000000;
    }
    .color-orange {
      background-color: #f5550f;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-orange td {
      color: #000000;
    }
    .bold-row td {
      font-weight: bold;
    }
    .highlight-red {
      background-color: rgba(249, 12, 12, 0.5) !important;
      transition: background-color 1s ease-out;
    }
    .highlight-red td {
      color: #ffffff !important;
      font-weight: bold;
    }
    tr.highlight-green {
      background-color: #00ff00 !important;
      transition: background-color 1s ease-out;
    }
    tr.highlight-green td {
      color: #000000 !important;
      font-weight: bold;
    }
    .legend {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-top: 10px;
    }
    .legend-row {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      border-radius: 3px;
      font-size: 10px;
      background-color: #2f2f2f;
      color: #cccccc;
      line-height: 1.2;
    }
    .legend .bid-updated-legend {
      background-color: #00ff00 !important;
      color: #000000 !important;
    }
    .copied {
      background-color: rgba(0, 255, 0, 0.3);
      transition: background-color 0.5s ease;
    }
    .price-cell:hover {
      background-color: rgba(0, 255, 0, 0.1);
      transition: none;
    }
    .highlight-total {
      background-color: #004d00;
      padding: 2px 4px;
      border-radius: 3px;
    }
    .error-message {
      color: #ff5555;
      text-align: center;
      margin: 10px 0;
      font-size: 14px;
    }
    #chart-container {
      width: 100%;
      height: 400px;
      margin-top: 20px;
      background-color: #2f2f2f;
      border: 1px solid #444;
      border-radius: 5px;
    }
    .chart-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      justify-content: center;
      align-items: center;
    }
    .chart-controls button,
    .chart-controls select {
      background-color: #333;
      color: #ffffff;
      border: 1px solid #444;
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 3px;
    }
    .chart-controls button:hover,
    .chart-controls select:hover {
      background-color: #444;
    }
    .select-price-btn {
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      font-size: 16px;
      color: #00ff00;
    }
    .select-price-btn:hover {
      opacity: 0.8;
    }
    .select-circle {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #444;
      cursor: pointer;
    }
    .select-circle:hover {
      background-color: #666;
    }
    .selected-row {
      background-color: rgba(0, 255, 0, 0.2);
    }
    .pair-selector {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 10px;
      justify-content: flex-start;
    }
    .pair-selector input {
      background-color: #333;
      color: #ffffff;
      border: 1px solid #444;
      padding: 5px 10px;
      font-size: 14px;
      border-radius: 3px;
      width: 150px;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <p id="local-time"></p>
  <p id="current-price">Current Price: Loading...</p>
  <div id="stats-timestamp">
    <p>diff orderbook Processed: <span id="diff-orderbook">0</span></p>
    <p>Total prices processed: <span id="total-prices">0</span></p>
    <p>API Status: <span id="websocket-status">Connecting...</span></p>
  </div>
  <div id="error-message" class="error-message"></div>

  <div class="pair-selector">
    <input list="pair-selector" id="pair-search" placeholder="Buscar par (ej. BTCUSDT)" value="BTCUSDT" oninput="filterPairs()" onchange="changePair()" onclick="this.value=''" />
    <datalist id="pair-selector"></datalist>
  </div>
  <div class="chart-controls">
    <button onclick="autoScaleChart()">Auto Scale</button>
    <select id="timeframe-selector" onchange="changeTimeframe()">
      <option value="15m">15m</option>
      <option value="1h" selected>1h</option>
      <option value="4h">4h</option>
      <option value="1d">1d</option>
    </select>
    <button onclick="exportLines()">Export/Import Lines</button>
    <select id="zones-selector" onchange="updateZones()">
      <option value="10">10</option>
      <option value="15">15</option>
      <option value="20">20</option>
      <option value="25">25</option>
      <option value="30" selected>30</option>
      <option value="100">100</option>
    </select>
  </div>
  <div id="chart-container"></div>

  <div class="container">
    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="bids-indicator-start"></span>
        <div class="total-count bids-total" id="bids-total">BIDS - 0 | TOTAL: 0</div>
        <span class="indicator-circle indicator-circle-end" id="bids-indicator-end"></span>
      </div>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Age</th>
            <th>Price</th>
            <th>QTY</th>
            <th>USDT</th>
            <th>% to price</th>
            <th>Acc USDT</th>
            <th>Acc QTY</th>
            <th>Hits</th>
            <th>Select</th>
          </tr>
        </thead>
        <tbody id="bids-body"></tbody>
      </table>
      <div class="legend">
        <div class="legend-row bid-updated-legend" style="background-color: #00ff00 !important; color: #000000 !important;">Bid updated (Buy, Black Text)</div>
        <div class="legend-row" style="background-color: #090ef5 !important; color: #ffffff !important;">Bids Within 0.5% to 1% of markPrice (White Text)</div>
        <div class="legend-row" style="background-color: #e0f30a !important; color: #000000 !important;">Bids Within 0.1% to 0.5% of markPrice (Black Text)</div>
        <div class="legend-row" style="background-color: #f5550f !important; color: #000000 !important;">Bids Within 0.1% of markPrice (Black Text)</div>
      </div>
    </div>

    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="asks-indicator-start"></span>
        <div class="total-count asks-total" id="asks-total">ASKS - 0 | TOTAL: 0</div>
        <span class="indicator-circle indicator-circle-end" id="asks-indicator-end"></span>
      </div>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Age</th>
            <th>Price</th>
            <th>QTY</th>
            <th>USDT</th>
            <th>% to price</th>
            <th>Acc USDT</th>
            <th>Acc QTY</th>
            <th>Hits</th>
            <th>Select</th>
          </tr>
        </thead>
        <tbody id="asks-body"></tbody>
      </table>
      <div class="legend">
        <div class="legend-row" style="background-color: rgba(249, 12, 12, 0.5) !important; color: #ffffff !important;">Ask updated (Sell, White Text)</div>
        <div class="legend-row" style="background-color: #090ef5 !important; color: #ffffff !important;">Asks Within 0.5% to 1% of markPrice (White Text)</div>
        <div class="legend-row" style="background-color: #e0f30a !important; color: #000000 !important;">Asks Within 0.1% to 0.5% of markPrice (Black Text)</div>
        <div class="legend-row" style="background-color: #f5550f !important; color: #000000 !important;">Asks Within 0.1% of markPrice (Black Text)</div>
      </div>
    </div>
  </div>

  <script>
    let symbol = "BTCUSDT";
    let currentTimeframe = "1h";
    let currentPrice = 0;
    let markPrice = 0;
    let asksData = [];
    let bidsData = [];
    let asksProcessed = 0;
    let bidsProcessed = 0;
    let diffOrderbookProcessed = 0;
    let pendingUpdate = false;
    let lastPriceUpdateTime = 0;
    let lastDepthUpdateTime = 0;
    let isInteracting = false;
    const INTERACTION_TIMEOUT_MS = 2000;
    const rowColors = new Map();
    const COLOR_DURATION_MS = 5000;
    let selectedPrices = new Map();
    let lastTableUpdate = 0;
    const TABLE_UPDATE_DEBOUNCE_MS = 100;
    let maxZones = 30;
    let allPairs = [];

    let chart = null;
    let candlestickSeries = null;
    let candlesData = [];
    let lastHoveredPrice = null;
    let markerTimeout = null;

    let tickerSocket = null;
    let depthSocket = null;
    let klineSocket = null;

    const utcOffset = -4;

    async function fetchPairs() {
      try {
        const response = await fetch("https://fapi.binance.com/fapi/v1/exchangeInfo");
        const data = await response.json();
        allPairs = data.symbols
          .filter((s) => s.contractType === "PERPETUAL")
          .map((s) => s.symbol)
          .sort();
        populatePairSelector();
      } catch (error) {
        console.error("Error fetching pairs:", error);
        document.getElementById("error-message").innerText =
          "Error loading pairs from Binance: " + error.message;
      }
    }

    function populatePairSelector() {
      const pairSelector = document.getElementById("pair-selector");
      pairSelector.innerHTML = "";
      allPairs.forEach((pair) => {
        const option = document.createElement("option");
        option.value = pair;
        option.text = pair;
        pairSelector.appendChild(option);
      });
      document.getElementById("pair-search").value = symbol;
    }

    function filterPairs() {
      const pairSearch = document.getElementById("pair-search");
      pairSearch.value = pairSearch.value.toUpperCase();
      const searchInput = pairSearch.value;
      const pairSelector = document.getElementById("pair-selector");
      pairSelector.innerHTML = "";
      const filteredPairs = allPairs.filter((pair) => pair.includes(searchInput));
      filteredPairs.forEach((pair) => {
        const option = document.createElement("option");
        option.value = pair;
        option.text = pair;
        pairSelector.appendChild(option);
      });
    }

    function changePair() {
      const newSymbol = document.getElementById("pair-search").value.toUpperCase();
      if (newSymbol && newSymbol !== symbol && allPairs.includes(newSymbol)) {
        symbol = newSymbol;
        asksData = [];
        bidsData = [];
        asksProcessed = 0;
        bidsProcessed = 0;
        diffOrderbookProcessed = 0;
        currentPrice = 0;
        markPrice = 0;
        candlesData = [];
        selectedPrices.clear();

        closeSockets();
        initializeSockets();
        loadHistoricalKlines();

        document.getElementById("pair-search").value = symbol;
      }
    }

    function initializeChart() {
      const chartContainer = document.getElementById("chart-container");
      chart = LightweightCharts.createChart(chartContainer, {
        width: chartContainer.offsetWidth,
        height: 400,
        layout: {
          background: { type: "solid", color: "#2f2f2f" },
          textColor: "#d1d4dc",
        },
        grid: {
          vertLines: { color: "#444" },
          horzLines: { color: "#444" },
        },
        timeScale: {
          timeVisible: true,
          secondsVisible: false,
        },
        rightPriceScale: {
          borderColor: "#444",
        },
        handleScroll: {
          mouseWheel: true,
          pressedMouseMove: true,
          horzTouchDrag: true,
          vertTouchDrag: true,
        },
        handleScale: {
          axisPressedMouseMove: true,
          mouseWheel: true,
          pinch: true,
        },
      });

      candlestickSeries = chart.addCandlestickSeries({
        upColor: "#00ff00",
        downColor: "#ff0000",
        borderVisible: false,
        wickUpColor: "#00ff00",
        wickDownColor: "#ff0000",
      });

      chart.applyOptions({
        priceScale: {
          scaleMargins: { top: 0.1, bottom: 0.1 },
        },
      });

      setupChartInteractions();
    }

    function getVisiblePriceRange() {
      if (!candlesData || candlesData.length === 0) return { minPrice: 0, maxPrice: 0 };
      const visibleRange = chart.timeScale().getVisibleRange();
      if (!visibleRange) return { minPrice: 0, maxPrice: 0 };
      const visibleCandles = candlesData.filter(
        (candle) => candle.time >= visibleRange.from && candle.time <= visibleRange.to
      );
      if (visibleCandles.length === 0) return { minPrice: 0, maxPrice: 0 };
      const minPrice = Math.min(...visibleCandles.map((candle) => candle.low));
      const maxPrice = Math.max(...visibleCandles.map((candle) => candle.high));
      return { minPrice, maxPrice };
    }

    function setupChartInteractions() {
      chart.subscribeCrosshairMove((param) => {
        if (!param || !param.point) return;
        const y = param.point.y;
        const chartContainer = document.getElementById("chart-container");
        const containerHeight = chartContainer.offsetHeight;
        const scaleMargins = { top: 0.1, bottom: 0.1 };
        const effectiveHeight = containerHeight * (1 - scaleMargins.top - scaleMargins.bottom);
        const heightOffset = containerHeight * scaleMargins.top;
        const adjustedY = y - heightOffset;
        if (adjustedY < 0 || adjustedY > effectiveHeight) return;
        const { minPrice, maxPrice } = getVisiblePriceRange();
        const priceRangeLength = maxPrice - minPrice;
        if (priceRangeLength <= 0) return;
        const pricePerPixel = priceRangeLength / effectiveHeight;
        const price = maxPrice - adjustedY * pricePerPixel;
        if (isNaN(price)) return;

        let closestPrice = null;
        let closestDistance = Infinity;
        let closestLine = null;

        selectedPrices.forEach((lineData, selectedPrice) => {
          const distance = Math.abs(selectedPrice - price);
          if (distance < closestDistance) {
            closestDistance = distance;
            closestPrice = selectedPrice;
            closestLine = lineData;
          }
        });

        const threshold = priceRangeLength * 0.03;
        if (closestDistance < threshold) {
          lastHoveredPrice = closestPrice;
          if (closestLine && !closestLine.marker) {
            closestLine.marker = closestLine.series.createPriceLine({
              price: closestPrice,
              color: closestLine.isAsk ? "#ff0000" : "#00ff00",
              lineWidth: 1,
              lineStyle: LightweightCharts.LineStyle.Dashed,
              title: "â Close",
            });
          }

          if (markerTimeout) {
            clearTimeout(markerTimeout);
            markerTimeout = null;
          }

          markerTimeout = setTimeout(() => {
            if (lastHoveredPrice === closestPrice) {
              if (closestLine.marker) {
                closestLine.series.removePriceLine(closestLine.marker);
                closestLine.marker = null;
                lastHoveredPrice = null;
              }
            }
          }, 2000);
        } else {
          if (!markerTimeout) {
            markerTimeout = setTimeout(() => {
              selectedPrices.forEach((lineData, priceKey) => {
                if (lineData.marker && priceKey === lastHoveredPrice) {
                  lineData.series.removePriceLine(lineData.marker);
                  lineData.marker = null;
                  lastHoveredPrice = null;
                }
              });
            }, 2000);
          }
        }
      });

      chart.subscribeClick((param) => {
        if (!param || !param.point) return;
        const y = param.point.y;
        const chartContainer = document.getElementById("chart-container");
        const containerHeight = chartContainer.offsetHeight;
        const scaleMargins = { top: 0.1, bottom: 0.1 };
        const effectiveHeight = containerHeight * (1 - scaleMargins.top - scaleMargins.bottom);
        const heightOffset = containerHeight * scaleMargins.top;
        const adjustedY = y - heightOffset;
        if (adjustedY < 0 || adjustedY > effectiveHeight) return;
        const { minPrice, maxPrice } = getVisiblePriceRange();
        const priceRangeLength = maxPrice - minPrice;
        if (priceRangeLength <= 0) return;
        const pricePerPixel = priceRangeLength / effectiveHeight;
        const price = maxPrice - adjustedY * pricePerPixel;
        if (isNaN(price)) return;

        let closestPrice = null;
        let closestDistance = Infinity;

        if (lastHoveredPrice !== null && selectedPrices.has(lastHoveredPrice)) {
          closestPrice = lastHoveredPrice;
          closestDistance = 0;
        } else {
          selectedPrices.forEach((selectedPrice) => {
            const distance = Math.abs(selectedPrice - price);
            if (distance < closestDistance) {
              closestDistance = distance;
              closestPrice = selectedPrice;
            }
          });
        }

        const threshold = priceRangeLength * 0.03;
        if (closestDistance < threshold && closestPrice !== null) {
          drawSelectedPriceLine(closestPrice, null, false);
          updateTableRowsAfterDeselect(closestPrice);
          lastHoveredPrice = null;
          if (markerTimeout) {
            clearTimeout(markerTimeout);
            markerTimeout = null;
          }
          ensureChartVisibility();
        }
      });
    }

    function updateTableRowsAfterDeselect(price) {
      const tableBodies = ["asks-body", "bids-body"];
      tableBodies.forEach((tableId) => {
        const tableBody = document.getElementById(tableId);
        Array.from(tableBody.children).forEach((row) => {
          const rowPrice = parseFloat(row.cells[2].textContent);
          if (rowPrice === price) {
            row.classList.remove("selected-row");
            updateSelectButton(row, price);
          }
        });
      });
    }

    function ensureChartVisibility() {
      if (chart && candlestickSeries && candlesData.length > 0) {
        candlestickSeries.setData(candlesData);
        chart.timeScale().fitContent();
      }
    }

    function saveHistoricalKlines() {
      const key = `${symbol}_${currentTimeframe}_klines`;
      localStorage.setItem(key, JSON.stringify(candlesData));
    }

    function loadHistoricalKlinesFromStorage() {
      const key = `${symbol}_${currentTimeframe}_klines`;
      const savedData = localStorage.getItem(key);
      if (savedData) {
        candlesData = JSON.parse(savedData);
        if (candlestickSeries && candlesData.length > 0) {
          candlestickSeries.setData(candlesData);
          chart.timeScale().fitContent();
        }
        return true;
      }
      return false;
    }

    async function loadHistoricalKlines() {
      if (loadHistoricalKlinesFromStorage()) {
        return;
      }
      try {
        const interval = currentTimeframe;
        const limit = 1000;
        const endTime = Date.now();
        const startTime = endTime - limit * getIntervalMs(interval);
        const response = await fetch(
          `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&startTime=${startTime}&endTime=${endTime}&limit=${limit}`
        );
        const data = await response.json();
        candlesData = data.map((kline) => ({
          time: Math.floor(kline[0] / 1000),
          open: parseFloat(kline[1]),
          high: parseFloat(kline[2]),
          low: parseFloat(kline[3]),
          close: parseFloat(kline[4]),
        }));
        if (candlestickSeries && candlesData.length > 0) {
          candlestickSeries.setData(candlesData);
          chart.timeScale().fitContent();
          saveHistoricalKlines();
        }
      } catch (error) {
        console.error("Error loading historical klines:", error);
        document.getElementById("error-message").innerText =
          "Error loading historical data: " + error.message;
      }
    }

    function getIntervalMs(interval) {
      const intervals = {
        "1m": 60 * 1000,
        "3m": 3 * 60 * 1000,
        "5m": 5 * 60 * 1000,
        "15m": 15 * 60 * 1000,
        "30m": 30 * 60 * 1000,
        "1h": 60 * 60 * 1000,
        "2h": 2 * 60 * 60 * 1000,
        "4h": 4 * 60 * 60 * 1000,
        "6h": 6 * 60 * 60 * 1000,
        "8h": 8 * 60 * 60 * 1000,
        "12h": 12 * 60 * 60 * 1000,
        "1d": 24 * 60 * 60 * 1000,
        "3d": 3 * 24 * 60 * 60 * 1000,
        "1w": 7 * 24 * 60 * 60 * 1000,
        "1M": 30 * 24 * 60 * 60 * 1000,
      };
      return intervals[interval] || intervals["1h"];
    }

    let isChangingTimeframe = false;
    let lastCandleTime = null;

    function handleKlineUpdate(klineData) {
      const kline = klineData.k;
      const candleData = {
        time: Math.floor(kline.t / 1000),
        open: parseFloat(kline.o),
        high: parseFloat(kline.h),
        low: parseFloat(kline.l),
        close: parseFloat(kline.c),
      };

      const lastCandle = candlesData[candlesData.length - 1];
      if (lastCandle && lastCandle.time === candleData.time) {
        candlesData[candlesData.length - 1] = candleData;
        candlestickSeries.update(candleData);
      } else {
        candlesData.push(candleData);
        if (candlesData.length > 1000) {
          candlesData.shift();
        }
        candlestickSeries.setData(candlesData);
        chart.timeScale().scrollToRealTime();
        lastCandleTime = candleData.time;
        saveHistoricalKlines();
      }
    }

    function changeTimeframe() {
      if (isChangingTimeframe) return;
      isChangingTimeframe = true;
      const newTimeframe = document.getElementById("timeframe-selector").value;
      if (newTimeframe === currentTimeframe) {
        isChangingTimeframe = false;
        return;
      }
      currentTimeframe = newTimeframe;

      candlesData = [];
      lastCandleTime = null;

      closeSockets();
      initializeSockets();
      loadHistoricalKlines().then(() => {
        ensureChartVisibility();
        isChangingTimeframe = false;
      }).catch((error) => {
        console.error("Error in changeTimeframe:", error);
        isChangingTimeframe = false;
        document.getElementById("error-message").innerText =
          "Error changing timeframe: " + error.message;
      });
    }

    function autoScaleChart() {
      if (chart) {
        chart.timeScale().fitContent();
        chart.priceScale().applyOptions({
          autoScale: true,
        });
      }
    }

    function exportLines() {
      const linesData = Array.from(selectedPrices.entries()).map(([price, line]) => ({
        price: price,
        color: line.isAsk ? "#ff0000" : "#00ff00",
        isAsk: line.isAsk,
      }));
      const blob = new Blob([JSON.stringify(linesData)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "selected_lines.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function updateZones() {
      maxZones = parseInt(document.getElementById("zones-selector").value);
      scheduleTableUpdate();
    }

    function initializeSockets() {
      const lowerSymbol = symbol.toLowerCase();

      tickerSocket = new WebSocket(`wss://fstream.binance.com/ws/${lowerSymbol}@ticker`);
      tickerSocket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        currentPrice = parseFloat(data.c);
        markPrice = parseFloat(data.p);
        document.getElementById("current-price").innerText = `${symbol} Price: ${formatPrice(currentPrice)}`;
        document.getElementById("websocket-status").innerText = "Connected";

        const startTime = performance.now();
        const timeSinceLastUpdate = startTime - lastPriceUpdateTime;
        lastPriceUpdateTime = startTime;
        updateTimestamp();
      };
      tickerSocket.onerror = (error) => {
        console.error("Ticker WebSocket error:", error);
        document.getElementById("websocket-status").innerText = "Error";
      };
      tickerSocket.onclose = () => {
        document.getElementById("websocket-status").innerText = "Disconnected";
      };

      depthSocket = new WebSocket(`wss://fstream.binance.com/ws/${lowerSymbol}@depth@100ms`);
      depthSocket.onmessage = (event) => {
        const startTime = performance.now();
        const now = Date.now();
        const data = JSON.parse(event.data);

        const newAsks = data.a || [];
        const newBids = data.b || [];

        asksData = updateOrders(asksData, newAsks, now, true);
        bidsData = updateOrders(bidsData, newBids, now, false);

        asksData.sort((a, b) => b.usdt - a.usdt);
        bidsData.sort((a, b) => b.usdt - a.usdt);

        asksData = asksData.slice(0, maxZones);
        bidsData = bidsData.slice(0, maxZones);

        diffOrderbookProcessed = Math.abs(asksProcessed - bidsProcessed);

        document.getElementById("diff-orderbook").innerText = diffOrderbookProcessed.toLocaleString();
        document.getElementById("asks-total").innerText = `ASKS - ${asksData.length} | TOTAL: ${asksProcessed.toLocaleString()}`;
        document.getElementById("bids-total").innerText = `BIDS - ${bidsData.length} | TOTAL: ${bidsProcessed.toLocaleString()}`;
        const totalPrices = asksProcessed + bidsProcessed;
        document.getElementById("total-prices").innerText = totalPrices.toLocaleString();

        if (totalPrices > 250000) {
          document.getElementById("total-prices").classList.add("highlight-total");
        }

        const asksIndicatorStart = document.getElementById("asks-indicator-start");
        const asksIndicatorEnd = document.getElementById("asks-indicator-end");
        const bidsIndicatorStart = document.getElementById("bids-indicator-start");
        const bidsIndicatorEnd = document.getElementById("bids-indicator-end");
        asksIndicatorStart.classList.remove("circle-red", "circle-green");
        asksIndicatorEnd.classList.remove("circle-red", "circle-green");
        bidsIndicatorStart.classList.remove("circle-red", "circle-green");
        bidsIndicatorEnd.classList.remove("circle-red", "circle-green");
        if (asksProcessed > bidsProcessed) {
          asksIndicatorStart.classList.add("circle-red");
          asksIndicatorEnd.classList.add("circle-red");
        } else if (bidsProcessed > asksProcessed) {
          bidsIndicatorStart.classList.add("circle-green");
          bidsIndicatorEnd.classList.add("circle-green");
        }

        const timeSinceLastUpdate = startTime - lastDepthUpdateTime;
        lastDepthUpdateTime = startTime;
        scheduleTableUpdate();
      };
      depthSocket.onerror = (error) => {
        console.error("Depth WebSocket error:", error);
        document.getElementById("websocket-status").innerText = "Error";
      };
      depthSocket.onclose = () => {
        document.getElementById("websocket-status").innerText = "Disconnected";
      };

      klineSocket = new WebSocket(
        `wss://fstream.binance.com/ws/${lowerSymbol}@kline_${currentTimeframe}`
      );
      klineSocket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleKlineUpdate(data);
      };
      klineSocket.onerror = (error) => {
        console.error("Kline WebSocket error:", error);
        document.getElementById("websocket-status").innerText = "Error";
      };
      klineSocket.onclose = () => {
        document.getElementById("websocket-status").innerText = "Disconnected";
      };
    }

    function closeSockets() {
      if (tickerSocket) {
        tickerSocket.close();
        tickerSocket = null;
      }
      if (depthSocket) {
        depthSocket.close();
        depthSocket = null;
      }
      if (klineSocket) {
        klineSocket.close();
        klineSocket = null;
      }
    }

    function initializeApp() {
      fetchPairs();
      initializeChart();
      if (chart && candlestickSeries) {
        loadHistoricalKlines().then(() => {
          initializeSockets();
          loadSelectedPrices();
        });
      }
    }

    function waitForLightweightCharts() {
      if (typeof LightweightCharts !== "undefined") {
        initializeApp();
      } else {
        setTimeout(waitForLightweightCharts, 100);
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      waitForLightweightCharts();
    });

    function saveSelectedPrices() {
      const prices = Array.from(selectedPrices.entries()).map(([price, line]) => ({
        price: price,
        isAsk: line.isAsk,
      }));
      localStorage.setItem("selectedPrices", JSON.stringify(prices));
    }

    function loadSelectedPrices() {
      const savedPrices = localStorage.getItem("selectedPrices");
      if (savedPrices) {
        const prices = JSON.parse(savedPrices);
        prices.forEach((item) => {
          const priceNum = parseFloat(item.price);
          const isAsk = item.isAsk;
          if (!isNaN(priceNum) && !selectedPrices.has(priceNum)) {
            drawSelectedPriceLine(priceNum, null, isAsk);
          }
        });
      }
    }

    function drawSelectedPriceLine(price, row, isAsk) {
      if (selectedPrices.has(price)) {
        const line = selectedPrices.get(price);
        if (line.marker) {
          line.series.removePriceLine(line.marker);
        }
        chart.removeSeries(line.series);
        selectedPrices.delete(price);
        if (row) {
          row.classList.remove("selected-row");
          updateSelectButton(row, price);
        }
        saveSelectedPrices();
        ensureChartVisibility();
        return;
      }

      const lineColor = isAsk ? "#ff0000" : "#00ff00";
      const lineSeries = chart.addLineSeries({
        color: lineColor,
        lineWidth: 1,
        priceLineVisible: false,
        lastValueVisible: false,
      });

      const now = Math.floor(Date.now() / 1000);
      lineSeries.setData([
        { time: now - 86400, value: price },
        { time: now, value: price },
      ]);

      lineSeries.createPriceLine({
        price: price,
        color: lineColor,
        lineWidth: 1,
        lineStyle: LightweightCharts.LineStyle.Solid,
        title: `Price: ${formatPrice(price)}`,
      });

      selectedPrices.set(price, { series: lineSeries, price: price, isAsk: isAsk, marker: null });
      if (row) {
        row.classList.add("selected-row");
        updateSelectButton(row, price);
      }
      saveSelectedPrices();
      ensureChartVisibility();
    }

    function updateSelectButton(row, price) {
      const selectCell = row.querySelector("td:last-child");
      if (selectCell) {
        if (selectedPrices.has(price)) {
          selectCell.innerHTML = `<button class="select-price-btn" data-price="${price}">ð</button>`;
        } else {
          selectCell.innerHTML = `<span class="select-circle" data-price="${price}"></span>`;
        }
      }
    }

    function redrawSelectedLines() {
      const pricesToRedraw = Array.from(selectedPrices.entries()).map(([price, lineData]) => ({
        price: price,
        isAsk: lineData.isAsk,
      }));
      selectedPrices.forEach((value, price) => {
        if (value.series) {
          if (value.marker) {
            value.series.removePriceLine(value.marker);
          }
          chart.removeSeries(value.series);
        }
      });
      selectedPrices.clear();
      pricesToRedraw.forEach((item) => {
        drawSelectedPriceLine(item.price, null, item.isAsk);
      });
      ensureChartVisibility();
    }

    window.addEventListener("resize", () => {
      if (chart) {
        const chartContainer = document.getElementById("chart-container");
        chart.resize(chartContainer.offsetWidth, 400);
        redrawSelectedLines();
      }
    });

    function setupEventListeners() {
      const tableBodies = document.querySelectorAll("#asks-body, #bids-body");
      tableBodies.forEach((tableBody) => {
        const isAsk = tableBody.id === "asks-body";
        tableBody.addEventListener("click", (event) => {
          const selectBtn = event.target.closest(".select-price-btn, .select-circle");
          if (selectBtn) {
            event.stopPropagation();
            event.preventDefault();
            const price = parseFloat(selectBtn.dataset.price);
            const row = selectBtn.closest("tr");
            if (row) {
              isInteracting = true;
              drawSelectedPriceLine(price, row, isAsk);
              setTimeout(() => {
                isInteracting = false;
              }, INTERACTION_TIMEOUT_MS);
            }
          }
        });

        tableBody.addEventListener("click", (event) => {
          const priceCell = event.target.closest(".price-cell");
          if (priceCell) {
            event.stopPropagation();
            event.preventDefault();
            isInteracting = true;
            copyPriceCell(priceCell);
            setTimeout(() => {
              isInteracting = false;
            }, INTERACTION_TIMEOUT_MS);
          }
        });
      });
    }

    function scheduleTableUpdate() {
      if (!pendingUpdate) {
        pendingUpdate = true;
        const now = Date.now();
        if (isInteracting) {
          setTimeout(() => {
            pendingUpdate = false;
            scheduleTableUpdate();
          }, TABLE_UPDATE_DEBOUNCE_MS);
          return;
        }
        if (now - lastTableUpdate < TABLE_UPDATE_DEBOUNCE_MS) {
          setTimeout(() => {
            pendingUpdate = false;
            scheduleTableUpdate();
          }, TABLE_UPDATE_DEBOUNCE_MS - (now - lastTableUpdate));
          return;
        }
        requestAnimationFrame(() => {
          updateTables();
          lastTableUpdate = Date.now();
          pendingUpdate = false;
        });
      }
    }

    function updateOrders(existingOrders, newOrders, now, isAsk) {
      const ordersMap = new Map(existingOrders.map((o) => [o.price, o]));

      newOrders.forEach(([p, q]) => {
        const price = parseFloat(p);
        const qty = parseFloat(q);
        if (isNaN(price) || isNaN(qty)) {
          console.warn(`Invalid price or qty: price=${p}, qty=${q}`);
          return;
        }
        const usdt = price * qty;

        if (qty === 0) {
          ordersMap.delete(price);
          rowColors.delete(price);
          if (isAsk) {
            asksProcessed--;
          } else {
            bidsProcessed--;
          }
        } else {
          if (ordersMap.has(price)) {
            const existing = ordersMap.get(price);
            const previousHits = existing.hits || 0;

            existing.qty = qty;
            existing.usdt = usdt;
            existing.lastUpdated = now;
            existing.hits = previousHits + 1;
            existing.colorAssignedTime = now;
          } else {
            ordersMap.set(price, {
              price,
              qty,
              usdt,
              lastUpdated: now,
              colorAssignedTime: now,
              hits: 1,
            });
            if (isAsk) {
              asksProcessed++;
            } else {
              bidsProcessed++;
            }
          }
        }
      });

      return Array.from(ordersMap.values());
    }

    function getColorClass(price, markPrice, isAsk, colorAssignedTime, now) {
      if (!markPrice || markPrice === 0) return "color-transparent";
      const diff = ((price - markPrice) / markPrice) * 100;
      const absDiff = Math.abs(diff);
      const colorAge = now - colorAssignedTime;

      if (colorAge > COLOR_DURATION_MS) {
        return "color-transparent";
      }

      if (absDiff <= 0.1) {
        return "color-orange";
      } else if (absDiff > 0.1 && absDiff <= 0.5) {
        return "color-yellow";
      } else if (absDiff > 0.5 && absDiff <= 1) {
        return "color-blue";
      }
      return "color-transparent";
    }

    function updateTables() {
      updateTable("asks-body", asksData, markPrice, true);
      updateTable("bids-body", bidsData, markPrice, false);
    }

    function updateTable(tableId, data, markPrice, isAsk) {
      const tableBody = document.getElementById(tableId);
      const now = Date.now();

      const existingRows = new Map();
      Array.from(tableBody.children).forEach((row) => {
        const price = parseFloat(row.cells[2].textContent);
        if (!isNaN(price)) {
          existingRows.set(price, row);
        }
      });

      let accUsdt = 0;
      let accQty = 0;

      const fragment = document.createDocumentFragment();
      data.forEach((item, idx) => {
        const ageTime = formatAge(now - item.lastUpdated);
        const pct = markPrice ? (((item.price - markPrice) / markPrice) * 100).toFixed(3) : "---";

        accUsdt += item.usdt;
        accQty += item.qty;

        let row = existingRows.get(item.price);
        if (!row) {
          row = document.createElement("tr");
          row.className = isAsk ? "ask-row" : "bid-row";
        }

        if (selectedPrices.has(item.price)) {
          row.classList.add("selected-row");
        } else {
          row.classList.remove("selected-row");
        }

        if (idx < 4) {
          row.classList.add("highlight-top");
        } else {
          row.classList.remove("highlight-top");
        }

        const newColorClass = getColorClass(item.price, markPrice, isAsk, item.colorAssignedTime || now, now);
        row.classList.remove("color-transparent", "color-blue", "color-yellow", "color-orange");
        row.classList.add(newColorClass);
        rowColors.set(item.price, newColorClass);

        if (newColorClass !== "color-transparent") {
          row.classList.add("bold-row");
        } else {
          row.classList.remove("bold-row");
        }

        const highlightDuration = 1000;
        const timeSinceUpdate = now - item.lastUpdated;
        if (timeSinceUpdate <= highlightDuration && item.hits > 1) {
          row.classList.add(isAsk ? "highlight-red" : "highlight-green");
        } else {
          row.classList.remove("highlight-red", "highlight-green");
        }

        row.innerHTML = `
          <td>${idx + 1}</td>
          <td>${ageTime}</td>
          <td class="price-cell">${formatPrice(item.price)}</td>
          <td>${formatQty(item.qty)}</td>
          <td>${formatUsdt(item.usdt)}</td>
          <td>${pct}</td>
          <td>${formatUsdt(accUsdt)}</td>
          <td>${formatQty(accQty)}</td>
          <td>${item.hits || 1}</td>
          <td>${
            selectedPrices.has(item.price)
              ? `<button class="select-price-btn" data-price="${item.price}">ð</button>`
              : `<span class="select-circle" data-price="${item.price}"></span>`
          }</td>
        `;
        fragment.appendChild(row);
        existingRows.delete(item.price);
      });

      existingRows.forEach((row) => row.remove());
      tableBody.appendChild(fragment);
    }

    function copyPriceCell(cell) {
      const priceText = cell.textContent.trim();
      navigator.clipboard.writeText(priceText).then(() => {
        cell.classList.add("copied");
      });
    }

    function formatPrice(value) {
      if (isNaN(value)) return "0.00";
      return parseFloat(value).toFixed(2);
    }

    function formatQty(value) {
      if (isNaN(value) || value === 0) return "0";
      if (value >= 1_000_000_000) {
        return (value / 1_000_000_000).toFixed(2) + "b";
      } else if (value >= 1_000_000) {
        return (value / 1_000_000).toFixed(2) + "m";
      } else if (value >= 1_000) {
        return (value / 1_000).toFixed(2) + "k";
      } else if (value < 0.001) {
        return value.toFixed(6);
      }
      return parseFloat(value).toFixed(4);
    }

    function formatUsdt(value) {
      if (isNaN(value) || value === 0) return "0.00";
      if (value >= 1_000_000_000) {
        return (value / 1_000_000_000).toFixed(2) + "b";
      } else if (value >= 1_000_000) {
        return (value / 1_000_000).toFixed(2) + "m";
      } else if (value >= 1_000) {
        return (value / 1_000).toFixed(2) + "k";
      } else if (value < 0.01) {
        return value.toFixed(4);
      }
      return parseFloat(value).toFixed(2);
    }

    function formatAge(ms) {
      const seconds = Math.floor(ms / 1000);
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m`;
      const hours = Math.floor(minutes / 60);
      return `${hours}h`;
    }

    function formatUtcOffset(offset) {
      const sign = offset >= 0 ? "+" : "-";
      const absOffset = Math.abs(offset);
      const hours = Math.floor(absOffset).toString().padStart(2, "0");
      const minutes = ((absOffset % 1) * 60).toString().padStart(2, "0");
      return `UTC${sign}${hours}:${minutes}`;
    }

    function updateTimestamp() {
      const now = new Date();
      now.setUTCHours(now.getUTCHours() + utcOffset);
      const options = {
        weekday: "short",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        fractionalSecondDigits: 1,
        hour12: true,
      };
      let formattedDate = now.toLocaleString("en-US", options);
      formattedDate = formattedDate.replace(/(\d{2})\/(\d{2})\/(\d{4})/, "$3-$1-$2");
      formattedDate += ` ${formatUtcOffset(utcOffset)}`;
      document.getElementById("local-time").innerText = formattedDate;
    }

    setupEventListeners();
    updateTimestamp();
  </script>
</body>
</html>
