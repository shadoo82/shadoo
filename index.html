<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Detalle del Símbolo</title>
  <script>
    console.log("Iniciando carga de orderbook.html...");
    window.addEventListener('load', () => {
      console.log("Evento 'load' disparado.");
      if (typeof LightweightCharts === 'undefined') {
        document.getElementById("error-message").textContent = "Error: No se pudo cargar Lightweight Charts desde el CDN. Verifica tu conexión o el enlace del CDN.";
        console.error("LightweightCharts no está definido. Verifica el enlace del CDN o tu conexión a internet.");
      } else {
        console.log("LightweightCharts cargado correctamente.");
      }
    });
  </script>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js" defer></script>
  <style>
    body {
      background-color: #1a1a1a;
      color: #ffffff;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }
    .back-button {
      text-align: center;
      margin-bottom: 20px;
    }
    .back-button button {
      background-color: #00ff00;
      color: #000000;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border-radius: 5px;
    }
    .back-button button:hover {
      background-color: #00cc00;
    }
    .header {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 20px;
      position: relative;
    }
    h1 {
      margin: 0;
      text-align: center;
      color: #00ff00;
      font-size: 24px;
      transition: color 0.1s ease;
    }
    h1 span {
      color: #00ff00;
    }
    #local-time {
      text-align: center;
      margin-bottom: 5px;
      color: #cccccc;
      font-size: 14px;
    }
    #stats-timestamp {
      text-align: center;
      margin-bottom: 20px;
      font-size: 14px;
    }
    #stats-timestamp p {
      margin: 2px 0;
      color: #cccccc;
    }
    .container {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .panel {
      flex: 1;
      border: 1px solid #444;
      background-color: #2f2f2f;
      padding: 5px 10px 10px 10px;
      min-width: 300px;
    }
    .title-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      width: 100%;
      text-align: center;
      margin-top: -5px;
    }
    .total-count {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 5px;
      text-align: center;
    }
    .asks-total {
      color: #ff0000;
    }
    .bids-total {
      color: #55ff55;
    }
    .indicator-circle {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    .indicator-circle-start {
      margin-right: 5px;
    }
    .indicator-circle-end {
      margin-left: 5px;
    }
    .circle-red {
      background-color: #ff0000 !important;
    }
    .circle-green {
      background-color: #00ff00 !important;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: #2a2a2a;
      border: 1px solid #444;
      margin-bottom: 10px;
      font-size: 10px;
    }
    th, td {
      padding: 4px;
      border: 1px solid #444;
      position: relative;
      cursor: pointer;
      line-height: 1.2;
      font-size: 10px;
    }
    th {
      background-color: #333;
      color: #00ff00;
      font-weight: 500;
      text-align: center;
    }
    td {
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    td span {
      display: inline-block;
      width: 100%;
      text-align: center;
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    td::selection, td span::selection {
      background: rgba(0, 255, 0, 0.3);
    }
    td::-moz-selection, td span::-moz-selection {
      background: rgba(0, 255, 0, 0.3);
    }
    .ask-row { color: #cccccc; }
    .bid-row { color: #cccccc; }
    tr:hover { background-color: #3a3a3a; }
    .highlight-top {
      background-color: rgba(255, 255, 0, 0.2);
      color: #ffffff;
      font-weight: bold;
    }
    .color-transparent {
      background-color: transparent;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-blue {
      background-color: #090ef5;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-blue td {
      color: #ffffff;
    }
    .color-yellow {
      background-color: #e0f30a;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-yellow td {
      color: #000000;
    }
    .color-orange {
      background-color: #f5550f;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-orange td {
      color: #000000;
    }
    .bold-row td {
      font-weight: bold;
    }
    .highlight-red {
      background-color: rgba(249, 12, 12, 0.5) !important;
      transition: background-color 1s ease-out;
    }
    .highlight-red td {
      color: #ffffff !important;
      font-weight: bold;
    }
    tr.highlight-green {
      background-color: #00ff00 !important;
      transition: background-color 1s ease-out;
    }
    tr.highlight-green td {
      color: #000000 !important;
      font-weight: bold;
    }
    .legend {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-top: 10px;
    }
    .legend-row {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      border-radius: 3px;
      font-size: 10px;
      background-color: #2f2f2f;
      color: #cccccc;
      line-height: 1.2;
    }
    .legend .bid-updated-legend {
      background-color: #00ff00 !important;
      color: #000000 !important;
    }
    .copied {
      background-color: rgba(0, 255, 0, 0.3);
      transition: background-color 0.5s ease;
    }
    .price-cell:hover {
      background-color: rgba(0, 255, 0, 0.1);
      transition: none;
    }
    .highlight-total {
      background-color: #004d00;
      padding: 2px 4px;
      border-radius: 3px;
    }
    .error-message {
      color: #ff5555;
      text-align: center;
      margin: 10px 0;
      font-size: 14px;
    }
    #chart-container {
      width: 100%;
      height: 400px;
      margin-top: 20px;
      background-color: #2f2f2f;
      border: 1px solid #444;
      border-radius: 5px;
    }
    .chart-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      justify-content: center;
      align-items: center;
    }
    .chart-controls button, .chart-controls select {
      background-color: #333;
      color: #ffffff;
      border: 1px solid #444;
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 3px;
    }
    .chart-controls button:hover, .chart-controls select:hover {
      background-color: #444;
    }
    .select-price-btn {
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      font-size: 16px;
      color: #00ff00;
    }
    .select-price-btn:hover {
      opacity: 0.8;
    }
    .select-circle {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #444;
      cursor: pointer;
    }
    .select-circle:hover {
      background-color: #666;
    }
    .selected-row {
      background-color: rgba(0, 255, 0, 0.2);
    }
    .debug-message {
      color: #00ff00;
      text-align: center;
      margin: 10px 0;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="debug-message" id="debug-message">Cargando orderbook.html...</div>
  <div class="back-button">
    <button onclick="window.location.href='/'">Atrás</button>
  </div>
  <div class="header">
    <h1 id="symbol-title"></h1>
  </div>
  <p id="local-time"></p>
  <div id="stats-timestamp">
    <p>diff orderbook Processed: <span id="diff-orderbook">0</span></p>
    <p>Total prices processed: <span id="total-prices">0</span></p>
    <p>WebSocket Status: <span id="websocket-status">Connecting...</span></p>
  </div>
  <div id="error-message" class="error-message"></div>

  <div class="chart-controls">
    <button onclick="autoScaleChart()">Auto Scale</button>
    <select id="timeframe-selector" onchange="changeTimeframe()">
      <option value="1h">1h</option>
      <option value="4h">4h</option>
      <option value="1d">1d</option>
    </select>
    <button onclick="exportLines()">Export/Import Lines</button>
  </div>
  <div id="chart-container"></div>

  <div class="container">
    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="bids-indicator-start"></span>
        <div class="total-count bids-total" id="bids-total">BIDS - 0 | TOTAL: 0</div>
        <span class="indicator-circle indicator-circle-end" id="bids-indicator-end"></span>
      </div>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Age</th>
            <th>Price</th>
            <th>QTY</th>
            <th>USDT</th>
            <th>% to price</th>
            <th>Acc USDT</th>
            <th>Acc QTY</th>
            <th>Hits</th>
            <th>Select</th>
          </tr>
        </thead>
        <tbody id="bids-body"></tbody>
      </table>
      <div class="legend">
        <div class="legend-row bid-updated-legend" style="background-color: #00ff00 !important; color: #000000 !important;">Bid updated (Buy, Black Text)</div>
        <div class="legend-row" style="background-color: #090ef5 !important; color: #ffffff !important;">Bids Within 0.5% to 1% of markPrice (White Text)</div>
        <div class="legend-row" style="background-color: #e0f30a !important; color: #000000 !important;">Bids Within 0.1% to 0.5% of markPrice (Black Text)</div>
        <div class="legend-row" style="background-color: #f5550f !important; color: #000000 !important;">Bids Within 0.1% of markPrice (Black Text)</div>
      </div>
    </div>

    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="asks-indicator-start"></span>
        <div class="total-count asks-total" id="asks-total">ASKS - 0 | TOTAL: 0</div>
        <span class="indicator-circle indicator-circle-end" id="asks-indicator-end"></span>
      </div>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Age</th>
            <th>Price</th>
            <th>QTY</th>
            <th>USDT</th>
            <th>% to price</th>
            <th>Acc USDT</th>
            <th>Acc QTY</th>
            <th>Hits</th>
            <th>Select</th>
          </tr>
        </thead>
        <tbody id="asks-body"></tbody>
      </table>
      <div class="legend">
        <div class="legend-row" style="background-color: rgba(249, 12, 12, 0.5) !important; color: #ffffff !important;">Ask updated (Sell, White Text)</div>
        <div class="legend-row" style="background-color: #090ef5 !important; color: #ffffff !important;">Asks Within 0.5% to 1% of markPrice (White Text)</div>
        <div class="legend-row" style="background-color: #e0f30a !important; color: #000000 !important;">Asks Within 0.1% to 0.5% of markPrice (Black Text)</div>
        <div class="legend-row" style="background-color: #f5550f !important; color: #000000 !important;">Asks Within 0.1% of markPrice (Black Text)</div>
      </div>
    </div>
  </div>

  <script>
    console.log("Iniciando script JavaScript...");
    document.getElementById("debug-message").textContent = "JavaScript iniciado. Conectando WebSockets...";

    const params = new URLSearchParams(window.location.search);
    const symbol = params.get("symbol") || "BTCUSDT";
    console.log("Símbolo detectado:", symbol);

    document.getElementById("symbol-title").innerText = `${symbol}: 0.0000 USDT`;
    let currentTimeframe = "1h";
    let tickerWsUrl = `wss://stream.binance.com:9443/ws/!miniTicker@arr`;
    let depthWsUrl = `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@depth@100ms`;
    let klineWsUrl = `wss://stream.binance.com:443/ws/${symbol.toLowerCase()}@kline_${currentTimeframe}`;
    let klineRestUrl = `https://api.binance.com/api/v3/klines?symbol=${symbol.toUpperCase()}&interval=${currentTimeframe}&limit=100`;
    console.log("URLs configuradas:", { tickerWsUrl, depthWsUrl, klineWsUrl, klineRestUrl });

    let currentPrice = 0;
    let asksData = [];
    let bidsData = [];
    let asksProcessed = 0;
    let bidsProcessed = 0;
    let diffOrderbookProcessed = 0;
    let pendingUpdate = false;
    let lastPriceUpdateTime = 0;
    let lastDepthUpdateTime = 0;
    let isInteracting = false;
    const INTERACTION_TIMEOUT_MS = 500;
    const rowColors = new Map();
    const COLOR_DURATION_MS = 5000;
    let selectedPrices = new Map();
    let lastTableUpdate = 0;
    const TABLE_UPDATE_DEBOUNCE_MS = 50;
    let klineReconnectAttempts = 0;
    const RECONNECT_DELAY_MS = 5000;

    const errorMessageElement = document.getElementById("error-message");
    const debugMessageElement = document.getElementById("debug-message");
    const websocketStatusElement = document.getElementById("websocket-status");

    let tickerSocketConnected = false;
    let depthSocketConnected = false;
    let klineSocketConnected = false;

    function updateWebSocketStatus() {
      const allConnected = tickerSocketConnected && depthSocketConnected && klineSocketConnected;
      const statusText = allConnected ? "All WebSockets Connected" : "Some WebSockets Disconnected";
      websocketStatusElement.textContent = statusText;
      websocketStatusElement.style.color = allConnected ? "#00ff00" : "#ff5555";
      console.log("Estado de WebSockets actualizado:", statusText);
    }

    function showError(message) {
      errorMessageElement.textContent = message;
      console.error("Error:", message);
    }

    function showDebug(message) {
      debugMessageElement.textContent = message;
      console.log("Debug:", message);
    }

    let chart = null;
    let candlestickSeries = null;
    let candlesData = [];
    let lastHoveredPrice = null;
    let markerTimeout = null;

    function initializeChart() {
      console.log("Inicializando gráfico...");
      try {
        if (typeof LightweightCharts === 'undefined') {
          throw new Error("LightweightCharts no está disponible. Verifica el enlace del CDN.");
        }

        const chartContainer = document.getElementById("chart-container");
        if (!chartContainer) {
          throw new Error("Contenedor del gráfico no encontrado (#chart-container).");
        }

        console.log("Dimensiones del contenedor del gráfico:", chartContainer.offsetWidth, "x", chartContainer.offsetHeight);
        if (chartContainer.offsetWidth === 0 || chartContainer.offsetHeight === 0) {
          console.warn("El contenedor del gráfico tiene dimensiones 0. Reintentando inicialización...");
          setTimeout(initializeChart, 500);
          return;
        }

        chart = LightweightCharts.createChart(chartContainer, {
          width: chartContainer.offsetWidth,
          height: 400,
          layout: {
            background: { type: 'solid', color: '#2f2f2f' },
            textColor: '#d1d4dc',
          },
          grid: {
            vertLines: { color: '#444' },
            horzLines: { color: '#444' },
          },
          timeScale: {
            timeVisible: true,
            secondsVisible: false,
          },
          rightPriceScale: {
            borderColor: '#444',
          },
          handleScroll: {
            mouseWheel: true,
            pressedMouseMove: true,
            horzTouchDrag: true,
            vertTouchDrag: true,
          },
          handleScale: {
            axisPressedMouseMove: true,
            mouseWheel: true,
            pinch: true,
          },
        });

        if (typeof chart.addCandlestickSeries !== 'function') {
          throw new Error("chart.addCandlestickSeries no es una función. Versión de Lightweight Charts incompatible.");
        }
        if (typeof chart.addLineSeries !== 'function') {
          throw new Error("chart.addLineSeries no es una función. Versión de Lightweight Charts incompatible.");
        }

        candlestickSeries = chart.addCandlestickSeries({
          upColor: '#00ff00',
          downColor: '#ff0000',
          borderVisible: false,
          wickUpColor: '#00ff00',
          wickDownColor: '#ff0000',
        });

        chart.applyOptions({
          priceScale: {
            scaleMargins: { top: 0.1, bottom: 0.1 },
          },
        });

        setupChartInteractions();

        console.log("Gráfico inicializado correctamente con Lightweight Charts v4.1.0");
        showDebug("Gráfico inicializado correctamente.");
      } catch (err) {
        showError(`Error al inicializar el gráfico: ${err.message}`);
        console.error("Detalles del error:", err);
      }
    }

    function getVisiblePriceRange() {
      if (!candlesData || candlesData.length === 0) {
        console.warn("No hay datos de velas disponibles para calcular el rango de precios.");
        return { minPrice: 0, maxPrice: 0 };
      }

      const visibleRange = chart.timeScale().getVisibleRange();
      if (!visibleRange) {
        console.warn("No se pudo obtener el rango visible del timeScale.");
        return { minPrice: 0, maxPrice: 0 };
      }

      const visibleCandles = candlesData.filter(candle => 
        candle.time >= visibleRange.from && candle.time <= visibleRange.to
      );

      if (visibleCandles.length === 0) {
        console.warn("No hay velas visibles en el rango actual.");
        return { minPrice: 0, maxPrice: 0 };
      }

      const minPrice = Math.min(...visibleCandles.map(candle => candle.low));
      const maxPrice = Math.max(...visibleCandles.map(candle => candle.high));

      console.log("Rango de precios visible calculado:", { minPrice, maxPrice });
      return { minPrice, maxPrice };
    }

    function setupChartInteractions() {
      if (!chart || !candlestickSeries) {
        console.warn("Chart o candlestickSeries no están inicializados. No se pueden configurar interacciones.");
        return;
      }

      chart.subscribeCrosshairMove((param) => {
        try {
          if (!param || !param.point) {
            console.log("CrosshairMove: Parámetro inválido o sin point:", param);
            return;
          }

          const y = param.point.y;
          console.log("Crosshair Y coordinate:", y);

          const chartContainer = document.getElementById("chart-container");
          const containerHeight = chartContainer.offsetHeight;
          if (containerHeight <= 0) {
            console.warn("Altura del contenedor del gráfico inválida:", containerHeight);
            return;
          }

          const scaleMargins = { top: 0.1, bottom: 0.1 };
          const effectiveHeight = containerHeight * (1 - scaleMargins.top - scaleMargins.bottom);
          const heightOffset = containerHeight * scaleMargins.top;

          const adjustedY = y - heightOffset;
          if (adjustedY < 0 || adjustedY > effectiveHeight) {
            console.log("Coordenada Y fuera del área efectiva del priceScale:", adjustedY);
            return;
          }

          const { minPrice, maxPrice } = getVisiblePriceRange();
          const priceRangeLength = maxPrice - minPrice;
          if (priceRangeLength <= 0) {
            console.warn("Rango de precios inválido:", priceRangeLength);
            return;
          }

          const pricePerPixel = priceRangeLength / effectiveHeight;
          const price = maxPrice - (adjustedY * pricePerPixel);
          console.log("Calculated price from Y coordinate:", price, "MinPrice:", minPrice, "MaxPrice:", maxPrice);

          if (isNaN(price)) {
            console.warn("Precio calculado inválido:", price);
            return;
          }

          let closestPrice = null;
          let closestDistance = Infinity;
          let closestLine = null;

          selectedPrices.forEach((lineData, selectedPrice) => {
            const distance = Math.abs(selectedPrice - price);
            if (distance < closestDistance) {
              closestDistance = distance;
              closestPrice = selectedPrice;
              closestLine = lineData;
            }
          });

          const threshold = priceRangeLength * 0.03;
          console.log("Threshold for showing 'X':", threshold, "Closest distance:", closestDistance);

          if (closestDistance < threshold) {
            lastHoveredPrice = closestPrice;
            if (closestLine && !closestLine.marker) {
              closestLine.marker = closestLine.series.createPriceLine({
                price: closestPrice,
                color: closest tareas.isAsk ? '#ff0000' : '#00ff00',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                title: '✖ Close',
              });
              console.log("Showing 'X' marker for price:", closestPrice);
            }

            if (markerTimeout) {
              clearTimeout(markerTimeout);
              markerTimeout = null;
            }

            markerTimeout = setTimeout(() => {
              if (lastHoveredPrice === closestPrice) {
                if (closestLine.marker) {
                  closestLine.series.removePriceLine(closestLine.marker);
                  closestLine.marker = null;
                  lastHoveredPrice = null;
                  console.log("Hiding 'X' marker after timeout for price:", closestPrice);
                }
              }
            }, 2000);
          } else {
            if (!markerTimeout) {
              markerTimeout = setTimeout(() => {
                selectedPrices.forEach((lineData, priceKey) => {
                  if (lineData.marker && priceKey === lastHoveredPrice) {
                    lineData.series.removePriceLine(lineData.marker);
                    lineData.marker = null;
                    lastHoveredPrice = null;
                    console.log("Hiding 'X' marker after leaving threshold for price:", priceKey);
                  }
                });
              }, 2000);
            }
          }
        } catch (err) {
          console.error("Error en subscribeCrosshairMove:", err);
          showError(`Error en interacción del gráfico: ${err.message}`);
        }
      });

      chart.subscribeClick((param) => {
        try {
          if (!param || !param.point) {
            console.log("Click: Parámetro inválido o sin point:", param);
            return;
          }

          const y = param.point.y;
          console.log("Click Y coordinate:", y);

          const chartContainer = document.getElementById("chart-container");
          const containerHeight = chartContainer.offsetHeight;
          if (containerHeight <= 0) {
            console.warn("Altura del contenedor del gráfico inválida al hacer clic:", containerHeight);
            return;
          }

          const scaleMargins = { top: 0.1, bottom: 0.1 };
          const effectiveHeight = containerHeight * (1 - scaleMargins.top - scaleMargins.bottom);
          const heightOffset = containerHeight * scaleMargins.top;

          const adjustedY = y - heightOffset;
          if (adjustedY < 0 || adjustedY > effectiveHeight) {
            console.log("Coordenada Y fuera del área efectiva al hacer clic:", adjustedY);
            return;
          }

          const { minPrice, maxPrice } = getVisiblePriceRange();
          const priceRangeLength = maxPrice - minPrice;
          if (priceRangeLength <= 0) {
            console.warn("Rango de precios inválido al hacer clic:", priceRangeLength);
            return;
          }

          const pricePerPixel = priceRangeLength / effectiveHeight;
          const price = maxPrice - (adjustedY * pricePerPixel);
          console.log("Calculated price from click:", price);

          if (isNaN(price)) {
            console.warn("Precio calculado inválido al hacer clic:", price);
            return;
          }

          let closestPrice = null;
          let closestDistance = Infinity;

          if (lastHoveredPrice !== null && selectedPrices.has(lastHoveredPrice)) {
            closestPrice = lastHoveredPrice;
            closestDistance = 0;
            console.log("Using last hovered price for click:", closestPrice);
          } else {
            selectedPrices.forEach((selectedPrice) => {
              const distance = Math.abs(selectedPrice - price);
              if (distance < closestDistance) {
                closestDistance = distance;
                closestPrice = selectedPrice;
              }
            });
          }

          const threshold = priceRangeLength * 0.03;
          console.log("Threshold for click:", threshold, "Closest distance:", closestDistance);

          if (closestDistance < threshold && closestPrice !== null) {
            console.log("Removing selected price on click:", closestPrice);
            drawSelectedPriceLine(closestPrice, null, false);
            updateTableRowsAfterDeselect(closestPrice);
            lastHoveredPrice = null;
            if (markerTimeout) {
              clearTimeout(markerTimeout);
              markerTimeout = null;
            }
          } else {
            console.log("Click fuera del umbral, no se elimina ninguna línea.");
          }
        } catch (err) {
          console.error("Error en subscribeClick:", err);
          showError(`Error al hacer clic en el gráfico: ${err.message}`);
        }
      });
    }

    function updateTableRowsAfterDeselect(price) {
      try {
        const tableBodies = ['asks-body', 'bids-body'];
        tableBodies.forEach(tableId => {
          const tableBody = document.getElementById(tableId);
          Array.from(tableBody.children).forEach(row => {
            const rowPrice = parseFloat(row.cells[2].textContent);
            if (rowPrice === price) {
              row.classList.remove("selected-row");
              updateSelectButton(row, price);
            }
          });
        });
      } catch (err) {
        console.error("Error en updateTableRowsAfterDeselect:", err);
        showError(`Error al deseleccionar precio en tabla: ${err.message}`);
      }
    }

    async function loadHistoricalKlines() {
      console.log("Cargando historial de velas...");
      try {
        console.log("URL de Kline REST:", klineRestUrl);
        const response = await fetch(klineRestUrl);
        if (!response.ok) {
          throw new Error(`Error HTTP: ${response.status} - ${response.statusText}`);
        }
        const data = await response.json();
        console.log("Datos históricos recibidos:", data);

        candlesData = data.map(kline => ({
          time: Math.floor(kline[0] / 1000),
          open: parseFloat(kline[1]),
          high: parseFloat(kline[2]),
          low: parseFloat(kline[3]),
          close: parseFloat(kline[4]),
        }));

        if (candlestickSeries) {
          candlestickSeries.setData(candlesData);
          chart.timeScale().fitContent();
          console.log("Historial de velas cargado:", candlesData);
          showDebug("Historial de velas cargado.");
        } else {
          console.warn("candlestickSeries no está inicializada. No se puede cargar el historial de velas.");
          showDebug("Error: candlestickSeries no inicializada.");
        }
      } catch (err) {
        showError(`Error al cargar el historial de velas: ${err.message}`);
        console.error("Detalles del error:", err);
      }
    }

    let klineSocket = null;
    let isChangingTimeframe = false;
    let lastCandleTime = null;

    function setupKlineSocket() {
      console.log("Configurando Kline WebSocket...");
      try {
        klineSocket = new WebSocket(klineWsUrl);
        klineSocket.onopen = () => {
          console.log("Kline WebSocket conectado:", klineWsUrl);
          showDebug("Kline WebSocket conectado.");
          klineSocketConnected = true;
          klineReconnectAttempts = 0;
          updateWebSocketStatus();
        };
        klineSocket.onerror = (error) => {
          const errorMsg = error.message || "Error desconocido";
          showError(`Error en la conexión de Kline WebSocket: ${errorMsg}.`);
          console.error("Error de Kline WebSocket:", error);
          klineSocketConnected = false;
          updateWebSocketStatus();
        };
        klineSocket.onclose = () => {
          klineSocketConnected = false;
          updateWebSocketStatus();
          if (!isChangingTimeframe) {
            klineReconnectAttempts++;
            showError(`Kline WebSocket cerrado. Intento de reconexión ${klineReconnectAttempts}...`);
            console.log(`Kline WebSocket cerrado. Intentando reconectar (intento ${klineReconnectAttempts})...`);
            setTimeout(() => {
              setupKlineSocket();
            }, RECONNECT_DELAY_MS);
          } else {
            console.log("Kline WebSocket cerrado durante cambio de temporalidad, no se intentará reconectar automáticamente.");
          }
        };
        klineSocket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            console.log("Mensaje recibido de Kline WebSocket:", data);

            const kline = data.k;
            if (!kline) {
              console.warn("Kline data no contiene 'k'. Datos recibidos:", data);
              return;
            }

            if (!kline.t || !kline.o || !kline.h || !kline.l || !kline.c) {
              console.warn("Datos de Kline incompletos:", kline);
              return;
            }

            const time = Math.floor(kline.t / 1000);
            const open = parseFloat(kline.o);
            const high = parseFloat(kline.h);
            const low = parseFloat(kline.l);
            const close = parseFloat(kline.c);

            if (isNaN(time) || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
              console.warn("Datos de Kline inválidos:", { time, open, high, low, close });
              return;
            }

            const candleData = { time, open, high, low, close };

            if (!candlestickSeries) {
              console.warn("candlestickSeries no está inicializada. Omitiendo actualización de velas.");
              return;
            }

            if (lastCandleTime && lastCandleTime === time) {
              candlestickSeries.update(candleData);
              candlesData[candlesData.length - 1] = candleData;
              console.log("Vela actualizada:", candleData);
            } else {
              candlesData.push(candleData);
              candlestickSeries.setData(candlesData);
              chart.timeScale().fitContent();
              console.log("Nueva vela añadida:", candleData);
              lastCandleTime = time;
            }
          } catch (err) {
            showError(`Error al parsear mensaje de Kline WebSocket: ${err.message}`);
            console.error("Error detalles:", err);
          }
        };
      } catch (err) {
        console.error("Error al configurar Kline WebSocket:", err);
        showError(`Error al configurar Kline WebSocket: ${err.message}`);
      }
    }

    window.changeTimeframe = function() {
      if (isChangingTimeframe) {
        console.log("Cambio de temporalidad en curso, esperando...");
        return;
      }
      isChangingTimeframe = true;
      console.log("Cambiando temporalidad...");

      try {
        currentTimeframe = document.getElementById("timeframe-selector").value;
        klineWsUrl = `wss://stream.binance.com:443/ws/${symbol.toLowerCase()}@kline_${currentTimeframe}`;
        klineRestUrl = `https://api.binance.com/api/v3/klines?symbol=${symbol.toUpperCase()}&interval=${currentTimeframe}&limit=100`;
        console.log("Nueva temporalidad:", currentTimeframe);
        console.log("Nueva URL de Kline:", klineWsUrl);

        if (klineSocket) {
          console.log("Cerrando WebSocket anterior...");
          klineSocket.onclose = null;
          klineSocket.close();
          klineSocket = null;
          klineSocketConnected = false;
          updateWebSocketStatus();
        }

        setTimeout(() => {
          klineReconnectAttempts = 0;
          setupKlineSocket();
          loadHistoricalKlines();
          isChangingTimeframe = false;
          console.log("Cambio de temporalidad completado.");
        }, 1000);
      } catch (err) {
        console.error("Error al cambiar temporalidad:", err);
        showError(`Error al cambiar temporalidad: ${err.message}`);
        isChangingTimeframe = false;
      }
    };

    window.autoScaleChart = function() {
      console.log("Autoescalando gráfico...");
      try {
        if (chart) {
          chart.timeScale().fitContent();
          chart.priceScale().applyOptions({
            autoScale: true,
          });
          console.log("Gráfico autoescalado.");
        } else {
          console.warn("Chart no inicializado. No se puede autoescalar.");
        }
      } catch (err) {
        console.error("Error al autoescalar gráfico:", err);
        showError(`Error al autoescalar gráfico: ${err.message}`);
      }
    };

    window.exportLines = function() {
      console.log("Exportando líneas...");
      try {
        const linesData = Array.from(selectedPrices.entries()).map(([price, line]) => ({
          price: price,
          color: line.isAsk ? '#ff0000' : '#00ff00',
          isAsk: line.isAsk,
        }));
        const blob = new Blob([JSON.stringify(linesData)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'selected_lines.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        console.log("Líneas exportadas:", linesData);
        showDebug("Líneas exportadas. Importación no soportada en este entorno.");
      } catch (err) {
        console.error("Error al exportar líneas:", err);
        showError(`Error al exportar líneas: ${err.message}`);
      }
    };

    function initializeApp() {
      console.log("Inicializando aplicación...");
      showDebug("Inicializando gráfico y cargando historial...");
      try {
        initializeChart();
        if (chart && candlestickSeries) {
          loadHistoricalKlines();
          setupKlineSocket();
          loadSelectedPrices();
        } else {
          console.warn("Chart o candlestickSeries no están inicializados al intentar cargar el historial.");
          showDebug("Error: Chart o candlestickSeries no inicializados al cargar historial.");
        }
      } catch (err) {
        console.error("Error al inicializar la aplicación:", err);
        showError(`Error al inicializar la aplicación: ${err.message}`);
      }
    }

    function waitForLightweightCharts() {
      try {
        if (typeof LightweightCharts !== 'undefined') {
          console.log("LightweightCharts está listo. Inicializando aplicación...");
          initializeApp();
        } else {
          console.log("Esperando a que LightweightCharts se cargue...");
          setTimeout(waitForLightweightCharts, 100);
        }
      } catch (err) {
        console.error("Error en waitForLightweightCharts:", err);
        showError(`Error al esperar LightweightCharts: ${err.message}`);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      console.log("Evento 'DOMContentLoaded' disparado.");
      waitForLightweightCharts();
    });

    function saveSelectedPrices() {
      try {
        const prices = Array.from(selectedPrices.entries()).map(([price, line]) => ({
          price: price,
          isAsk: line.isAsk,
        }));
        localStorage.setItem('selectedPrices', JSON.stringify(prices));
        console.log("Precios seleccionados guardados:", prices);
      } catch (err) {
        console.error("Error al guardar precios seleccionados:", err);
        showError(`Error al guardar precios seleccionados: ${err.message}`);
      }
    }

    function loadSelectedPrices() {
      try {
        const savedPrices = localStorage.getItem('selectedPrices');
        if (savedPrices) {
          const prices = JSON.parse(savedPrices);
          prices.forEach(item => {
            const priceNum = parseFloat(item.price);
            const isAsk = item.isAsk;
            if (!isNaN(priceNum) && !selectedPrices.has(priceNum)) {
              drawSelectedPriceLine(priceNum, null, isAsk);
            }
          });
          console.log("Precios seleccionados cargados:", prices);
        } else {
          console.log("No hay precios seleccionados guardados en localStorage.");
        }
      } catch (err) {
        console.error("Error al cargar precios seleccionados:", err);
        showError(`Error al cargar precios seleccionados: ${err.message}`);
      }
    }

    function drawSelectedPriceLine(price, row, isAsk) {
      console.log("Intentando dibujar línea para precio:", price, "isAsk:", isAsk);
      try {
        if (!chart || !candlestickSeries) {
          console.warn("Chart o candlestickSeries no están inicializados. No se puede dibujar la línea de precio.");
          showDebug("Error: Chart o candlestickSeries no inicializados al intentar dibujar línea.");
          return;
        }

        if (isNaN(price)) {
          console.error("Precio inválido:", price);
          showDebug("Error: Precio inválido para dibujar línea.");
          return;
        }

        if (selectedPrices.has(price)) {
          const line = selectedPrices.get(price);
          if (line.marker) {
            line.series.removePriceLine(line.marker);
          }
          chart.removeSeries(line.series);
          selectedPrices.delete(price);
          if (row) {
            row.classList.remove("selected-row");
            updateSelectButton(row, price);
          }
          console.log("Línea de precio deseleccionada:", price);
          showDebug(`Línea deseleccionada: ${price}`);
          saveSelectedPrices();
          return;
        }

        const lineColor = isAsk ? '#ff0000' : '#00ff00';
        const lineSeries = chart.addLineSeries({
          color: lineColor,
          lineWidth: 1,
          priceLineVisible: false,
          lastValueVisible: false,
        });

        const now = Math.floor(Date.now() / 1000);
        lineSeries.setData([
          { time: now - 86400, value: price },
          { time: now, value: price },
        ]);

        lineSeries.createPriceLine({
          price: price,
          color: lineColor,
          lineWidth: 1,
          lineStyle: LightweightCharts.LineStyle.Solid,
          title: `Price: ${formatPrice(price)}`,
        });

        selectedPrices.set(price, { series: lineSeries, price: price, isAsk: isAsk, marker: null });
        if (row) {
          row.classList.add("selected-row");
          updateSelectButton(row, price);
        }
        console.log("Línea de precio seleccionada dibujada:", price, "Color:", lineColor);
        showDebug(`Línea seleccionada: ${price}`);
        saveSelectedPrices();
      } catch (err) {
        console.error("Error al dibujar línea de precio:", err);
        showError(`Error al dibujar línea de precio: ${err.message}`);
      }
    }

    function updateSelectButton(row, price) {
      try {
        const selectCell = row.querySelector('td:last-child');
        if (selectCell) {
          if (selectedPrices.has(price)) {
            selectCell.innerHTML = `<button class="select-price-btn" data-price="${price}">📍</button>`;
          } else {
            selectCell.innerHTML = `<span class="select-circle" data-price="${price}"></span>`;
          }
        } else {
          console.error("No se encontró la celda de selección en la fila:", row);
        }
      } catch (err) {
        console.error("Error al actualizar botón de selección:", err);
        showError(`Error al actualizar botón de selección: ${err.message}`);
      }
    }

    function redrawSelectedLines() {
      console.log("Redibujando todas las líneas seleccionadas...");
      try {
        if (!chart) {
          console.warn("Chart no está inicializado. No se pueden redibujar las líneas.");
          return;
        }
        const pricesToRedraw = Array.from(selectedPrices.entries()).map(([price, lineData]) => ({
          price: price,
          isAsk: lineData.isAsk,
        }));
        selectedPrices.forEach((value, price) => {
          if (value.series) {
            if (value.marker) {
              value.series.removePriceLine(value.marker);
            }
            chart.removeSeries(value.series);
          }
        });
        selectedPrices.clear();
        pricesToRedraw.forEach(item => {
          console.log(`Redibujando línea para precio: ${item.price}, isAsk: ${item.isAsk}`);
          drawSelectedPriceLine(item.price, null, item.isAsk);
        });
        console.log("Líneas seleccionadas redibujadas:", selectedPrices.size);
      } catch (err) {
        console.error("Error al redibujar líneas seleccionadas:", err);
        showError(`Error al redibujar líneas seleccionadas: ${err.message}`);
      }
    }

    window.addEventListener('resize', () => {
      console.log("Evento de redimensionamiento disparado.");
      try {
        if (chart) {
          const chartContainer = document.getElementById("chart-container");
          chart.resize(chartContainer.offsetWidth, 400);
          console.log("Gráfico redimensionado:", chartContainer.offsetWidth, "x 400");
          redrawSelectedLines();
        } else {
          console.warn("Chart no inicializado durante redimensionamiento.");
        }
      } catch (err) {
        console.error("Error al redimensionar gráfico:", err);
        showError(`Error al redimensionar gráfico: ${err.message}`);
      }
    });

    function setupEventListeners() {
      console.log("Configurando event listeners...");
      try {
        const tableBodies = document.querySelectorAll('#asks-body, #bids-body');
        console.log("Tablas encontradas:", tableBodies.length);

        tableBodies.forEach(tableBody => {
          const isAsk = tableBody.id === 'asks-body';
          tableBody.addEventListener('click', (event) => {
            const target = event.target;
            if (target.classList.contains('select-price-btn') || target.classList.contains('select-circle')) {
              console.log("Evento click directo en elemento de selección:", target);
              event.stopPropagation();
              event.preventDefault();
              const price = parseFloat(target.dataset.price);
              const row = target.closest('tr');
              console.log("Botón de selección clicado, precio:", price, "Fila:", row);
              if (row) {
                isInteracting = true;
                console.log("isInteracting establecido a true por selección.");
                drawSelectedPriceLine(price, row, isAsk);
                setTimeout(() => {
                  isInteracting = false;
                  console.log("isInteracting reseteado después de interacción.");
                }, INTERACTION_TIMEOUT_MS);
              } else {
                console.error("No se encontró la fila asociada al botón de selección.");
                showDebug("Error: No se encontró la fila para el precio seleccionado.");
              }
            }
          });

          tableBody.addEventListener('click', (event) => {
            const priceCell = event.target.closest('.price-cell');
            if (priceCell) {
              console.log("Evento click en celda de precio:", priceCell);
              event.stopPropagation();
              event.preventDefault();
              isInteracting = true;
              console.log("isInteracting establecido a true por copia de precio.");
              copyPriceCell(priceCell);
              setTimeout(() => {
                isInteracting = false;
                console.log("isInteracting reseteado después de copiar precio.");
              }, INTERACTION_TIMEOUT_MS);
            }
          });
        });
      } catch (err) {
        console.error("Error al configurar event listeners:", err);
        showError(`Error al configurar event listeners: ${err.message}`);
      }
    }

    function setupTickerSocket() {
      try {
        const tickerSocket = new WebSocket(tickerWsUrl);
        tickerSocket.onopen = () => {
          console.log("Ticker WebSocket conectado:", tickerWsUrl);
          showDebug("Ticker WebSocket conectado.");
          tickerSocketConnected = true;
          updateWebSocketStatus();
        };
        tickerSocket.onerror = (error) => {
          const errorMsg = error.message || "Error desconocido";
          showError(`Error en la conexión de Ticker WebSocket: ${errorMsg}.`);
          console.error("Error de Ticker WebSocket:", error);
          tickerSocketConnected = false;
          updateWebSocketStatus();
        };
        tickerSocket.onclose = () => {
          tickerSocketConnected = false;
          updateWebSocketStatus();
          showError("Ticker WebSocket cerrado. Intentando reconectar...");
          console.log("Ticker WebSocket cerrado. Reconectando...");
          setTimeout(() => {
            setupTickerSocket();
          }, RECONNECT_DELAY_MS);
        };
        tickerSocket.onmessage = (event) => {
          const startTime = performance.now();
          try {
            const data = JSON.parse(event.data);
            console.log("Mensaje recibido de Ticker WebSocket:", data);
            const symbolData = data.find(item => item.s === symbol.toUpperCase());
            if (symbolData) {
              const newPrice = parseFloat(symbolData.c);
              console.log(`Ticker update: currentPrice=${currentPrice}, newPrice=${newPrice}`);
              currentPrice = newPrice;
              document.getElementById("symbol-title").innerText = `${symbol}: ${formatPrice(currentPrice)} USDT`;

              const endTime = performance.now();
              const timeSinceLastUpdate = startTime - lastPriceUpdateTime;
              lastPriceUpdateTime = startTime;
              console.log(`Tiempo de actualización del precio: ${(endTime - startTime).toFixed(2)}ms`);
              console.log(`Tiempo desde la última actualización del precio: ${timeSinceLastUpdate.toFixed(2)}ms`);

              updateTimestamp();
              scheduleTableUpdate();
            }
          } catch (err) {
            showError(`Error al parsear mensaje de Ticker WebSocket: ${err.message}`);
            console.error("Error detalles:", err);
          }
        };
        return tickerSocket;
      } catch (err) {
        console.error("Error al configurar Ticker WebSocket:", err);
        showError(`Error al configurar Ticker WebSocket: ${err.message}`);
      }
    }

    function setupDepthSocket() {
      try {
        const depthSocket = new WebSocket(depthWsUrl);
        depthSocket.onopen = () => {
          console.log("Depth WebSocket conectado:", depthWsUrl);
          showDebug("Depth WebSocket conectado.");
          depthSocketConnected = true;
          updateWebSocketStatus();
        };
        depthSocket.onerror = (error) => {
          const errorMsg = error.message || "Error desconocido";
          showError(`Error en la conexión de Depth WebSocket: ${errorMsg}.`);
          console.error("Error de Depth WebSocket:", error);
          depthSocketConnected = false;
          updateWebSocketStatus();
        };
        depthSocket.onclose = () => {
          depthSocketConnected = false;
          updateWebSocketStatus();
          showError("Depth WebSocket cerrado. Intentando reconectar...");
          console.log("Depth WebSocket cerrado. Reconectando...");
          setTimeout(() => {
            setupDepthSocket();
          }, RECONNECT_DELAY_MS);
        };
        depthSocket.onmessage = (event) => {
          const startTime = performance.now();
          try {
            const data = JSON.parse(event.data);
            const now = Date.now();
            console.log("Mensaje recibido de Depth WebSocket:", JSON.stringify(data));

            if (data.a) {
              console.log(`Procesando ${data.a.length} actualizaciones de asks:`, data.a);
              asksData = updateOrders(asksData, data.a, now, true);
              asksProcessed += data.a.length;
            }
            if (data.b) {
              console.log(`Procesando ${data.b.length} actualizaciones de bids:`, data.b);
              bidsData = updateOrders(bidsData, data.b, now, false);
              bidsProcessed += data.b.length;
            }

            diffOrderbookProcessed = Math.abs(asksProcessed - bidsProcessed);

            if (currentPrice > 0) {
              asksData = asksData.filter(item => {
                const diff = Math.abs((item.price - currentPrice) / currentPrice) * 100;
                return diff <= 10;
              });
              bidsData = bidsData.filter(item => {
                const diff = Math.abs((item.price - currentPrice) / currentPrice) * 100;
                return diff <= 10;
              });
            }

            asksData.sort((a, b) => b.usdt - a.usdt);
            bidsData.sort((a, b) => b.usdt - a.usdt);

            asksData = asksData.slice(0, 30);
            bidsData = bidsData.slice(0, 30);

            document.getElementById("diff-orderbook").innerText = diffOrderbookProcessed.toLocaleString();
            document.getElementById("asks-total").innerText = `ASKS - ${asksData.length} | TOTAL: ${asksProcessed.toLocaleString()}`;
            document.getElementById("bids-total").innerText = `BIDS - ${bidsData.length} | TOTAL: ${bidsProcessed.toLocaleString()}`;
            const totalPrices = asksProcessed + bidsProcessed;
            document.getElementById("total-prices").innerText = totalPrices.toLocaleString();

            if (totalPrices > 250000) {
              document.getElementById("total-prices").classList.add("highlight-total");
            }

            const asksIndicatorStart = document.getElementById("asks-indicator-start");
            const asksIndicatorEnd = document.getElementById("asks-indicator-end");
            const bidsIndicatorStart = document.getElementById("bids-indicator-start");
            const bidsIndicatorEnd = document.getElementById("bids-indicator-end");
            asksIndicatorStart.classList.remove("circle-red", "circle-green");
            asksIndicatorEnd.classList.remove("circle-red", "circle-green");
            bidsIndicatorStart.classList.remove("circle-red", "circle-green");
            bidsIndicatorEnd.classList.remove("circle-red", "circle-green");
            if (asksProcessed > bidsProcessed) {
              asksIndicatorStart.classList.add("circle-red");
              asksIndicatorEnd.classList.add("circle-red");
              console.log(`Asks processed (${asksProcessed}) > Bids processed (${bidsProcessed}): Showing red circles for Top Asks`);
            } else if (bidsProcessed > asksProcessed) {
              bidsIndicatorStart.classList.add("circle-green");
              bidsIndicatorEnd.classList.add("circle-green");
              console.log(`Bids processed (${bidsProcessed}) > Asks processed (${asksProcessed}): Showing green circles for Top Bids`);
            }

            scheduleTableUpdate();
          } catch (err) {
            showError(`Error al procesar mensaje de Depth WebSocket: ${err.message}`);
            console.error("Error detalles:", err);
          }
        };
        return depthSocket;
      } catch (err) {
        console.error("Error al configurar Depth WebSocket:", err);
        showError(`Error al configurar Depth WebSocket: ${err.message}`);
      }
    }

    setupTickerSocket();
    setupDepthSocket();
    setupEventListeners();

    function scheduleTableUpdate() {
      if (!pendingUpdate) {
        pendingUpdate = true;
        const now = Date.now();
        if (isInteracting) {
          console.log('Actualización de tabla retrasada: usuario interactuando.');
          setTimeout(() => {
            pendingUpdate = false;
            scheduleTableUpdate();
          }, TABLE_UPDATE_DEBOUNCE_MS);
          return;
        }
        if (now - lastTableUpdate < TABLE_UPDATE_DEBOUNCE_MS) {
          console.log('Actualización de tabla retrasada para evitar regeneración rápida.');
          setTimeout(() => {
            pendingUpdate = false;
            scheduleTableUpdate();
          }, TABLE_UPDATE_DEBOUNCE_MS - (now - lastTableUpdate));
          return;
        }
        requestAnimationFrame(() => {
          try {
            updateTables();
            lastTableUpdate = Date.now();
            pendingUpdate = false;
            console.log('Tabla actualizada.');
            showDebug("Tablas actualizadas.");
          } catch (err) {
            console.error("Error al actualizar tablas:", err);
            showError(`Error al actualizar tablas: ${err.message}`);
            pendingUpdate = false;
          }
        });
      } else {
        console.log("Actualización de tabla ya programada, esperando...");
      }
    }

    function updateOrders(existingOrders, newOrders, now, isAsk) {
      console.log("Actualizando órdenes...");
      try {
        const ordersMap = new Map(existingOrders.map(o => [o.price, o]));

        newOrders.forEach(([p, q]) => {
          const price = parseFloat(p);
          const qty = parseFloat(q);
          const usdt = price * qty;

          console.log(`Procesando actualización: price=${price}, qty=${qty}, usdt=${usdt}`);

          if (qty === 0) {
            ordersMap.delete(price);
            rowColors.delete(price);
            console.log(`Price ${price} eliminado`);
          } else {
            if (ordersMap.has(price)) {
              const existing = ordersMap.get(price);
              const previousHits = existing.hits || 0;

              existing.qty = qty;
              existing.usdt = usdt;
              existing.lastUpdated = now;
              existing.hits = previousHits + 1;
              existing.colorAssignedTime = now;

              console.log(`Price ${price} actualizado: hits=${existing.hits}, qty=${qty}, usdt=${usdt}, lastUpdated=${existing.lastUpdated}`);
            } else {
              ordersMap.set(price, {
                price,
                qty,
                usdt,
                lastUpdated: now,
                colorAssignedTime: now,
                hits: 1,
              });
              console.log(`Nuevo precio ${price} añadido: hits=1, qty=${qty}, usdt=${usdt}, lastUpdated=${now}`);
            }
          }
        });

        return Array.from(ordersMap.values());
      } catch (err) {
        console.error("Error al actualizar órdenes:", err);
        showError(`Error al actualizar órdenes: ${err.message}`);
        return existingOrders;
      }
    }

    function getColorClass(price, markPrice, isAsk, colorAssignedTime, now) {
      try {
        const diff = ((price - markPrice) / markPrice) * 100;
        const absDiff = Math.abs(diff);
        const colorAge = now - colorAssignedTime;

        if (colorAge > COLOR_DURATION_MS) {
          console.log(`Price ${price}: color expirado después de ${colorAge}ms, estableciendo color-transparent`);
          return "color-transparent";
        }

        let colorClass;
        if (absDiff <= 0.1) {
          colorClass = "color-orange";
        } else if (absDiff > 0.1 && absDiff <= 0.5) {
          colorClass = "color-yellow";
        } else if (absDiff > 0.5 && absDiff <= 1) {
          colorClass = "color-blue";
        } else {
          colorClass = "color-transparent";
        }

        console.log(`Price ${price}: markPrice=${markPrice}, absDiff=${absDiff.toFixed(3)}%, color=${colorClass}`);
        return colorClass;
      } catch (err) {
        console.error("Error al obtener clase de color:", err);
        showError(`Error al obtener clase de color: ${err.message}`);
        return "color-transparent";
      }
    }

    function updateTables() {
      console.log("Actualizando tablas...");
      updateTable("asks-body", asksData, currentPrice, true);
      updateTable("bids-body", bidsData, currentPrice, false);
    }

    function updateTable(tableId, data, markPrice, isAsk) {
      console.log(`Actualizando tabla ${tableId}...`);
      try {
        const tableBody = document.getElementById(tableId);
        const now = Date.now();

        const existingRows = new Map();
        Array.from(tableBody.children).forEach(row => {
          const price = parseFloat(row.cells[2].textContent);
          existingRows.set(price, row);
        });

        let accUsdt = 0;
        let accQty = 0;

        const fragment = document.createDocumentFragment();
        data.forEach((item, idx) => {
          const ageTime = formatAge(now - item.lastUpdated);
          console.log(`Calculando edad para precio ${item.price}: now=${now}, lastUpdated=${item.lastUpdated}, age=${ageTime}`);
          const pct = markPrice ? (((item.price - markPrice) / markPrice) * 100).toFixed(3) : "---";
          
          accUsdt += item.usdt;
          accQty += item.qty;

          console.log(`Formateando QTY: item.qty=${item.qty}, accQty=${accQty}`);

          let row = existingRows.get(item.price);
          if (!row) {
            row = document.createElement("tr");
            row.className = isAsk ? "ask-row" : "bid-row";
          }

          if (selectedPrices.has(item.price)) {
            row.classList.add("selected-row");
          } else {
            row.classList.remove("selected-row");
          }

          if (idx < 4) {
            row.classList.add("highlight-top");
          } else {
            row.classList.remove("highlight-top");
          }

          const newColorClass = getColorClass(item.price, markPrice, isAsk, item.colorAssignedTime || now, now);
          row.classList.remove("color-transparent", "color-blue", "color-yellow", "color-orange");
          row.classList.add(newColorClass);
          rowColors.set(item.price, newColorClass);

          if (newColorClass !== "color-transparent") {
            row.classList.add("bold-row");
          } else {
            row.classList.remove("bold-row");
          }

          const recentlyUpdated = item.lastUpdated && (now - item.lastUpdated) <= 1000;
          if (recentlyUpdated) {
            console.log(`Aplicando resaltado para precio ${item.price}: isAsk=${isAsk}, recentlyUpdated=${recentlyUpdated}`);
            const highlightClass = isAsk ? "highlight-red" : "highlight-green";
            row.classList.remove("highlight-red", "highlight-green");
            row.classList.add(highlightClass);

            setTimeout(() => {
              try {
                row.classList.remove("highlight-red", "highlight-green");
                row.classList.remove("color-transparent", "color-blue", "color-yellow", "color-orange");
                const updatedColorClass = getColorClass(item.price, currentPrice, isAsk, item.colorAssignedTime || now, now);
                row.classList.add(updatedColorClass);
                rowColors.set(item.price, updatedColorClass);
                if (updatedColorClass !== "color-transparent") {
                  row.classList.add("bold-row");
                } else {
                  row.classList.remove("bold-row");
                }
                console.log(`Reaplicado color class para precio ${item.price}: ${updatedColorClass}`);
              } catch (err) {
                console.error("Error al reaplicar clase de color después de resaltado:", err);
                showError(`Error al reaplicar clase de color: ${err.message}`);
              }
            }, 1000);
          } else {
            row.classList.remove("highlight-red", "highlight-green");
          }

          console.log(`Generando botón de selección para precio ${item.price}: ${selectedPrices.has(item.price) ? "📍" : "círculo"}`);

          row.innerHTML = `
            <td><span>${idx + 1}</span></td>
            <td class="age-cell"><span>${ageTime}</span></td>
            <td class="price-cell"><span>${formatPrice(item.price)}</span></td>
            <td><span>${formatQty(item.qty)}</span></td>
            <td><span>${formatUsdt(item.usdt)}</span></td>
            <td><span>${pct !== "---" ? pct + "%" : "---"}</span></td>
            <td><span>${formatUsdt(accUsdt)}</span></td>
            <td><span>${formatQty(accQty)}</span></td>
            <td><span>${item.hits}</span></td>
            <td>${selectedPrices.has(item.price) ? `<button class="select-price-btn" data-price="${item.price}">📍</button>` : `<span class="select-circle" data-price="${item.price}"></span>`}</td>
          `;
          fragment.appendChild(row);
          existingRows.delete(item.price);
        });

        existingRows.forEach(row => {
          row.remove();
        });

        tableBody.innerHTML = '';
        tableBody.appendChild(fragment);
      } catch (err) {
        console.error(`Error al actualizar la tabla ${tableId}:`, err);
        showError(`Error al actualizar la tabla ${tableId}: ${err.message}`);
      }
    }

    function formatPrice(price) {
      try {
        if (typeof price !== 'number' || isNaN(price)) {
          console.error("Precio inválido para formatear:", price);
          return "0.0000";
        }
        return price.toFixed(4);
      } catch (err) {
        console.error("Error al formatear precio:", err);
        return "0.0000";
      }
    }

    function formatQty(qty) {
      try {
        const numQty = parseFloat(qty);
        if (isNaN(numQty)) {
          console.error("Cantidad no es un número válido:", qty);
          return "0.0000";
        }
        if (numQty >= 1_000_000_000) {
          return `${(numQty / 1_000_000_000).toFixed(2)}B`;
        } else if (numQty >= 1_000_000) {
          return `${(numQty / 1_000_000).toFixed(2)}M`;
        } else if (numQty >= 1_000) {
          return `${(numQty / 1_000).toFixed(2)}K`;
        } else {
          return numQty.toFixed(4);
        }
      } catch (err) {
        console.error("Error al formatear cantidad:", err);
        return "0.0000";
      }
    }

    function formatUsdt(usdt) {
      try {
        const numUsdt = parseFloat(usdt);
        if (isNaN(numUsdt)) {
          console.error("USDT no es un número válido:", usdt);
          return "0.00";
        }
        if (numUsdt >= 1_000_000_000) {
          return `${(numUsdt / 1_000_000_000).toFixed(2)}B`;
        } else if (numUsdt >= 1_000_000) {
          return `${(numUsdt / 1_000_000).toFixed(2)}M`;
        } else if (numUsdt >= 1_000) {
          return `${(numUsdt / 1_000).toFixed(2)}K`;
        } else {
          return numUsdt.toFixed(2);
        }
      } catch (err) {
        console.error("Error al formatear USDT:", err);
        return "0.00";
      }
    }

    function formatAge(ms) {
      try {
        if (ms < 0) {
          return "0s";
        }
        const seconds = Math.floor(ms / 1000);
        if (seconds < 60) {
          return `${seconds}s`;
        }
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        if (minutes < 60) {
          return `${minutes}m${remainingSeconds.toString().padStart(2, '0')}s`;
        }
        const hours = Math.floor(minutes / 60);
        const remainingMinutes = minutes % 60;
        return `${hours}h${remainingMinutes.toString().padStart(2, '0')}m`;
      } catch (err) {
        console.error("Error al formatear edad:", err);
        return "0s";
      }
    }

    function copyPriceCell(cell) {
      try {
        const priceText = cell.textContent.trim();
        navigator.clipboard.writeText(priceText).then(() => {
          cell.classList.add("copied");
          console.log(`Precio copiado al portapapeles: ${priceText}`);
          showDebug(`Precio copiado: ${priceText}`);
        }).catch(err => {
          console.error("Error al copiar precio:", err);
          showError(`Error al copiar precio: ${err.message}`);
        });
      } catch (err) {
        console.error("Error en copyPriceCell:", err);
        showError(`Error al copiar precio: ${err.message}`);
      }
    }

    function updateTimestamp() {
      try {
        const now = new Date();
        document.getElementById("local-time").innerText = `Local Time: ${now.toLocaleString
