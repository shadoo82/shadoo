<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Detalle del SÃ­mbolo</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    body {
      background-color: #1a1a1a;
      color: #ffffff;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }
    #local-time {
      text-align: center;
      margin-bottom: 5px;
      color: #cccccc;
      font-size: 14px;
    }
    #current-price {
      text-align: center;
      margin-bottom: 5px;
      color: #00ff00;
      font-size: 16px;
    }
    #stats-timestamp {
      text-align: center;
      margin-bottom: 20px;
      font-size: 14px;
    }
    #stats-timestamp p {
      margin: 2px 0;
      color: #cccccc;
    }
    .container {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .panel {
      flex: 1;
      border: 1px solid #444;
      background-color: #2f2f2f;
      padding: 5px 10px 10px 10px;
      min-width: 300px;
    }
    .title-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      width: 100%;
      text-align: center;
      margin-top: -5px;
    }
    .total-count {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 5px;
      text-align: center;
    }
    .asks-total {
      color: #ff0000;
    }
    .bids-total {
      color: #55ff55;
    }
    .indicator-circle {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    .indicator-circle-start {
      margin-right: 5px;
    }
    .indicator-circle-end {
      margin-left: 5px;
    }
    .circle-red {
      background-color: #ff0000 !important;
    }
    .circle-green {
      background-color: #00ff00 !important;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: #2a2a2a;
      border: 1px solid #444;
      margin-bottom: 10px;
      font-size: 10px;
    }
    th, td {
      padding: 4px;
      border: 1px solid #444;
      position: relative;
      cursor: pointer;
      line-height: 1.2;
      font-size: 10px;
    }
    th {
      background-color: #333;
      color: #00ff00;
      font-weight: 500;
      text-align: center;
    }
    td {
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    td span {
      display: inline-block;
      width: 100%;
      text-align: center;
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    td::selection, td span::selection {
      background: rgba(0, 255, 0, 0.3);
    }
    td::-moz-selection, td span::-moz-selection {
      background: rgba(0, 255, 0, 0.3);
    }
    .ask-row { color: #cccccc; }
    .bid-row { color: #cccccc; }
    tr:hover { background-color: #3a3a3a; }
    .highlight-top {
      background-color: rgba(255, 255, 0, 0.2);
      color: #ffffff;
      font-weight: bold;
    }
    .color-transparent {
      background-color: transparent;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-blue {
      background-color: #090ef5;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-blue td {
      color: #ffffff;
    }
    .color-yellow {
      background-color: #e0f30a;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-yellow td {
      color: #000000;
    }
    .color-orange {
      background-color: #f5550f;
      transition: background-color 0.2s ease-out, color 0.2s ease-out;
    }
    .color-orange td {
      color: #000000;
    }
    .bold-row td {
      font-weight: bold;
    }
    .highlight-red {
      background-color: rgba(249, 12, 12, 0.5) !important;
      transition: background-color 1s ease-out;
    }
    .highlight-red td {
      color: #ffffff !important;
      font-weight: bold;
    }
    tr.highlight-green {
      background-color: #00ff00 !important;
      transition: background-color 1s ease-out;
    }
    tr.highlight-green td {
      color: #000000 !important;
      font-weight: bold;
    }
    .legend {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-top: 10px;
    }
    .legend-row {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      border-radius: 3px;
      font-size: 10px;
      background-color: #2f2f2f;
      color: #cccccc;
      line-height: 1.2;
    }
    .legend .bid-updated-legend {
      background-color: #00ff00 !important;
      color: #000000 !important;
    }
    .copied {
      background-color: rgba(0, 255, 0, 0.3);
      transition: background-color 0.5s ease;
    }
    .price-cell:hover {
      background-color: rgba(0, 255, 0, 0.1);
      transition: none;
    }
    .highlight-total {
      background-color: #004d00;
      padding: 2px 4px;
      border-radius: 3px;
    }
    .error-message {
      color: #ff5555;
      text-align: center;
      margin: 10px 0;
      font-size: 14px;
    }
    #chart-container {
      width: 100%;
      height: 400px;
      margin-top: 20px;
      background-color: #2f2f2f;
      border: 1px solid #444;
      border-radius: 5px;
    }
    .chart-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      justify-content: center;
      align-items: center;
    }
    .chart-controls button, .chart-controls select {
      background-color: #333;
      color: #ffffff;
      border: 1px solid #444;
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 3px;
    }
    .chart-controls button:hover, .chart-controls select:hover {
      background-color: #444;
    }
    .select-price-btn {
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      font-size: 16px;
      color: #00ff00;
    }
    .select-price-btn:hover {
      opacity: 0.8;
    }
    .select-circle {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #444;
      cursor: pointer;
    }
    .select-circle:hover {
      background-color: #666;
    }
    .selected-row {
      background-color: rgba(0, 255, 0, 0.2);
    }
    .pair-selector {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 10px;
      justify-content: flex-start;
    }
    .pair-selector input {
      background-color: #333;
      color: #ffffff;
      border: 1px solid #444;
      padding: 5px 10px;
      font-size: 14px;
      border-radius: 3px;
      width: 150px;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <p id="local-time"></p>
  <p id="current-price">Current Price: Loading...</p>
  <div id="stats-timestamp">
    <p>diff orderbook Processed: <span id="diff-orderbook">0</span></p>
    <p>Total prices processed: <span id="total-prices">0</span></p>
    <p>WebSocket Status: <span id="websocket-status">Connecting...</span></p>
  </div>
  <div id="error-message" class="error-message"></div>

  <div class="pair-selector">
    <input list="pair-selector" id="pair-search" placeholder="Buscar par (ej. BTCUSDT)" value="BTCUSDT" oninput="filterPairs()" onchange="changePair()" onclick="this.value=''" />
    <datalist id="pair-selector"></datalist>
  </div>
  <div class="chart-controls">
    <button onclick="autoScaleChart()">Auto Scale</button>
    <select id="timeframe-selector" onchange="changeTimeframe()">
      <option value="15m">15m</option>
      <option value="1h" selected>1h</option>
      <option value="4h">4h</option>
      <option value="1d">1d</option>
    </select>
    <button onclick="exportLines()">Export/Import Lines</button>
    <select id="zones-selector" onchange="updateZones()">
      <option value="10">10</option>
      <option value="15">15</option>
      <option value="20">20</option>
      <option value="25">25</option>
      <option value="30" selected>30</option>
      <option value="100">100</option>
    </select>
  </div>
  <div id="chart-container"></div>

  <div class="container">
    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="bids-indicator-start"></span>
        <div class="total-count bids-total" id="bids-total">BIDS - 0 | TOTAL: 0</div>
        <span class="indicator-circle indicator-circle-end" id="bids-indicator-end"></span>
      </div>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Age</th>
            <th>Price</th>
            <th>QTY</th>
            <th>USDT</th>
            <th>% to price</th>
            <th>Acc USDT</th>
            <th>Acc QTY</th>
            <th>Hits</th>
            <th>Select</th>
          </tr>
        </thead>
        <tbody id="bids-body"></tbody>
      </table>
      <div class="legend">
        <div class="legend-row bid-updated-legend" style="background-color: #00ff00 !important; color: #000000 !important;">Bid updated (Buy, Black Text)</div>
        <div class="legend-row" style="background-color: #090ef5 !important; color: #ffffff !important;">Bids Within 0.5% to 1% of markPrice (White Text)</div>
        <div class="legend-row" style="background-color: #e0f30a !important; color: #000000 !important;">Bids Within 0.1% to 0.5% of markPrice (Black Text)</div>
        <div class="legend-row" style="background-color: #f5550f !important; color: #000000 !important;">Bids Within 0.1% of markPrice (Black Text)</div>
      </div>
    </div>

    <div class="panel">
      <div class="title-row">
        <span class="indicator-circle indicator-circle-start" id="asks-indicator-start"></span>
        <div class="total-count asks-total" id="asks-total">ASKS - 0 | TOTAL: 0</div>
        <span class="indicator-circle indicator-circle-end" id="asks-indicator-end"></span>
      </div>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Age</th>
            <th>Price</th>
            <th>QTY</th>
            <th>USDT</th>
            <th>% to price</th>
            <th>Acc USDT</th>
            <th>Acc QTY</th>
            <th>Hits</th>
            <th>Select</th>
          </tr>
        </thead>
        <tbody id="asks-body"></tbody>
      </table>
      <div class="legend">
        <div class="legend-row" style="background-color: rgba(249, 12, 12, 0.5) !important; color: #ffffff !important;">Ask updated (Sell, White Text)</div>
        <div class="legend-row" style="background-color: #090ef5 !important; color: #ffffff !important;">Asks Within 0.5% to 1% of markPrice (White Text)</div>
        <div class="legend-row" style="background-color: #e0f30a !important; color: #000000 !important;">Asks Within 0.1% to 0.5% of markPrice (Black Text)</div>
        <div class="legend-row" style="background-color: #f5550f !important; color: #000000 !important;">Asks Within 0.1% of markPrice (Black Text)</div>
      </div>
    </div>
  </div>

  <script>
    let symbol = "BTCUSDT";
    let currentTimeframe = "1h";
    let tickerWsUrl = `wss://fstream.binance.com/ws/!miniTicker@arr`;
    let depthWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@depth@100ms`;
    let klineWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${currentTimeframe}`;
    let klineRestUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${currentTimeframe}&limit=100`;

    let currentPrice = 0;
    let asksData = [];
    let bidsData = [];
    let asksProcessed = 0;
    let bidsProcessed = 0;
    let diffOrderbookProcessed = 0;
    let pendingUpdate = false;
    let lastPriceUpdateTime = 0;
    let lastDepthUpdateTime = 0;
    let isInteracting = false;
    const INTERACTION_TIMEOUT_MS = 2000;
    const rowColors = new Map();
    const COLOR_DURATION_MS = 5000;
    let selectedPrices = new Map();
    let lastTableUpdate = 0;
    const TABLE_UPDATE_DEBOUNCE_MS = 100;
    let klineReconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_DELAY_MS = 5000;
    let maxZones = 30;
    let tickerSocket = null;
    let depthSocket = null;
    let klineSocket = null;

    let chart = null;
    let candlestickSeries = null;
    let candlesData = [];
    let lastHoveredPrice = null;
    let markerTimeout = null;
    let allPairs = [];

    // ConfiguraciÃ³n de la zona horaria (ajusta utcOffset segÃºn necesites)
    const utcOffset = -4; // Cambia este valor para otros UTC offsets, ej. 0 para UTC+00:00, +1 para UTC+01:00

    async function fetchPairs() {
      try {
        const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
        const data = await response.json();
        allPairs = data.symbols
          .filter(s => s.symbol.endsWith('USDT') && s.status === 'TRADING')
          .map(s => s.symbol)
          .sort();
        populatePairSelector();
      } catch (error) {
        console.error('Error fetching pairs:', error);
        document.getElementById("error-message").innerText = "Error loading pairs from Binance Futures: " + error.message;
      }
    }

    function populatePairSelector() {
      const pairSelector = document.getElementById("pair-selector");
      pairSelector.innerHTML = '';
      allPairs.forEach(pair => {
        const option = document.createElement("option");
        option.value = pair;
        option.text = pair;
        pairSelector.appendChild(option);
      });
      document.getElementById("pair-search").value = symbol;
    }

    function filterPairs() {
      const pairSearch = document.getElementById("pair-search");
      pairSearch.value = pairSearch.value.toUpperCase();
      const searchInput = pairSearch.value;
      const pairSelector = document.getElementById("pair-selector");
      pairSelector.innerHTML = '';
      const filteredPairs = allPairs.filter(pair => pair.includes(searchInput));
      filteredPairs.forEach(pair => {
        const option = document.createElement("option");
        option.value = pair;
        option.text = pair;
        pairSelector.appendChild(option);
      });
    }

    function changePair() {
      const newSymbol = document.getElementById("pair-search").value.toUpperCase();
      if (newSymbol && newSymbol !== symbol && allPairs.includes(newSymbol)) {
        symbol = newSymbol;
        depthWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@depth@100ms`;
        klineWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${currentTimeframe}`;
        klineRestUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${currentTimeframe}&limit=100`;

        asksData = [];
        bidsData = [];
        asksProcessed = 0;
        bidsProcessed = 0;
        diffOrderbookProcessed = 0;
        currentPrice = 0;
        candlesData = [];
        selectedPrices.clear();

        if (tickerSocket) {
          tickerSocket.close();
        }
        if (depthSocket) {
          depthSocket.close();
        }
        if (klineSocket) {
          klineSocket.close();
        }

        tickerSocket = setupTickerSocket();
        depthSocket = setupDepthSocket();
        setupKlineSocket();
        loadHistoricalKlines();

        document.getElementById("pair-search").value = symbol;
      }
    }

    function initializeChart() {
      const chartContainer = document.getElementById("chart-container");
      chart = LightweightCharts.createChart(chartContainer, {
        width: chartContainer.offsetWidth,
        height: 400,
        layout: {
          background: { type: 'solid', color: '#2f2f2f' },
          textColor: '#d1d4dc',
        },
        grid: {
          vertLines: { color: '#444' },
          horzLines: { color: '#444' },
        },
        timeScale: {
          timeVisible: true,
          secondsVisible: false,
        },
        rightPriceScale: {
          borderColor: '#444',
        },
        handleScroll: {
          mouseWheel: true,
          pressedMouseMove: true,
          horzTouchDrag: true,
          vertTouchDrag: true,
        },
        handleScale: {
          axisPressedMouseMove: true,
          mouseWheel: true,
          pinch: true,
        },
      });

      candlestickSeries = chart.addCandlestickSeries({
        upColor: '#00ff00',
        downColor: '#ff0000',
        borderVisible: false,
        wickUpColor: '#00ff00',
        wickDownColor: '#ff0000',
      });

      chart.applyOptions({
        priceScale: {
          scaleMargins: { top: 0.1, bottom: 0.1 },
        },
      });

      setupChartInteractions();
    }

    function getVisiblePriceRange() {
      if (!candlesData || candlesData.length === 0) return { minPrice: 0, maxPrice: 0 };
      const visibleRange = chart.timeScale().getVisibleRange();
      if (!visibleRange) return { minPrice: 0, maxPrice: 0 };
      const visibleCandles = candlesData.filter(candle => 
        candle.time >= visibleRange.from && candle.time <= visibleRange.to
      );
      if (visibleCandles.length === 0) return { minPrice: 0, maxPrice: 0 };
      const minPrice = Math.min(...visibleCandles.map(candle => candle.low));
      const maxPrice = Math.max(...visibleCandles.map(candle => candle.high));
      return { minPrice, maxPrice };
    }

    function setupChartInteractions() {
      chart.subscribeCrosshairMove((param) => {
        if (!param || !param.point) return;
        const y = param.point.y;
        const chartContainer = document.getElementById("chart-container");
        const containerHeight = chartContainer.offsetHeight;
        const scaleMargins = { top: 0.1, bottom: 0.1 };
        const effectiveHeight = containerHeight * (1 - scaleMargins.top - scaleMargins.bottom);
        const heightOffset = containerHeight * scaleMargins.top;
        const adjustedY = y - heightOffset;
        if (adjustedY < 0 || adjustedY > effectiveHeight) return;
        const { minPrice, maxPrice } = getVisiblePriceRange();
        const priceRangeLength = maxPrice - minPrice;
        if (priceRangeLength <= 0) return;
        const pricePerPixel = priceRangeLength / effectiveHeight;
        const price = maxPrice - (adjustedY * pricePerPixel);
        if (isNaN(price)) return;

        let closestPrice = null;
        let closestDistance = Infinity;
        let closestLine = null;

        selectedPrices.forEach((lineData, selectedPrice) => {
          const distance = Math.abs(selectedPrice - price);
          if (distance < closestDistance) {
            closestDistance = distance;
            closestPrice = selectedPrice;
            closestLine = lineData;
          }
        });

        const threshold = priceRangeLength * 0.03;
        if (closestDistance < threshold) {
          lastHoveredPrice = closestPrice;
          if (closestLine && !closestLine.marker) {
            closestLine.marker = closestLine.series.createPriceLine({
              price: closestPrice,
              color: closestLine.isAsk ? '#ff0000' : '#00ff00',
              lineWidth: 1,
              lineStyle: LightweightCharts.LineStyle.Dashed,
              title: 'â Close',
            });
          }

          if (markerTimeout) {
            clearTimeout(markerTimeout);
            markerTimeout = null;
          }

          markerTimeout = setTimeout(() => {
            if (lastHoveredPrice === closestPrice) {
              if (closestLine.marker) {
                closestLine.series.removePriceLine(closestLine.marker);
                closestLine.marker = null;
                lastHoveredPrice = null;
              }
            }
          }, 2000);
        } else {
          if (!markerTimeout) {
            markerTimeout = setTimeout(() => {
              selectedPrices.forEach((lineData, priceKey) => {
                if (lineData.marker && priceKey === lastHoveredPrice) {
                  lineData.series.removePriceLine(lineData.marker);
                  lineData.marker = null;
                  lastHoveredPrice = null;
                }
              });
            }, 2000);
          }
        }
      });

      chart.subscribeClick((param) => {
        if (!param || !param.point) return;
        const y = param.point.y;
        const chartContainer = document.getElementById("chart-container");
        const containerHeight = chartContainer.offsetHeight;
        const scaleMargins = { top: 0.1, bottom: 0.1 };
        const effectiveHeight = containerHeight * (1 - scaleMargins.top - scaleMargins.bottom);
        const heightOffset = containerHeight * scaleMargins.top;
        const adjustedY = y - heightOffset;
        if (adjustedY < 0 || adjustedY > effectiveHeight) return;
        const { minPrice, maxPrice } = getVisiblePriceRange();
        const priceRangeLength = maxPrice - minPrice;
        if (priceRangeLength <= 0) return;
        const pricePerPixel = priceRangeLength / effectiveHeight;
        const price = maxPrice - (adjustedY * pricePerPixel);
        if (isNaN(price)) return;

        let closestPrice = null;
        let closestDistance = Infinity;

        if (lastHoveredPrice !== null && selectedPrices.has(lastHoveredPrice)) {
          closestPrice = lastHoveredPrice;
          closestDistance = 0;
        } else {
          selectedPrices.forEach((selectedPrice) => {
            const distance = Math.abs(selectedPrice - price);
            if (distance < closestDistance) {
              closestDistance = distance;
              closestPrice = selectedPrice;
            }
          });
        }

        const threshold = priceRangeLength * 0.03;
        if (closestDistance < threshold && closestPrice !== null) {
          drawSelectedPriceLine(closestPrice, null, false);
          updateTableRowsAfterDeselect(closestPrice);
          lastHoveredPrice = null;
          if (markerTimeout) {
            clearTimeout(markerTimeout);
            markerTimeout = null;
          }
          ensureChartVisibility();
        }
      });
    }

    function updateTableRowsAfterDeselect(price) {
      const tableBodies = ['asks-body', 'bids-body'];
      tableBodies.forEach(tableId => {
        const tableBody = document.getElementById(tableId);
        Array.from(tableBody.children).forEach(row => {
          const rowPrice = parseFloat(row.cells[2].textContent);
          if (rowPrice === price) {
            row.classList.remove("selected-row");
            updateSelectButton(row, price);
          }
        });
      });
    }

    function ensureChartVisibility() {
      if (chart && candlestickSeries && candlesData.length > 0) {
        candlestickSeries.setData(candlesData);
        chart.timeScale().fitContent();
      }
    }

    function saveHistoricalKlines() {
      const key = `${symbol}_${currentTimeframe}_klines`;
      localStorage.setItem(key, JSON.stringify(candlesData));
    }

    function loadHistoricalKlinesFromStorage() {
      const key = `${symbol}_${currentTimeframe}_klines`;
      const savedData = localStorage.getItem(key);
      if (savedData) {
        candlesData = JSON.parse(savedData);
        if (candlestickSeries && candlesData.length > 0) {
          candlestickSeries.setData(candlesData);
          chart.timeScale().fitContent();
        }
        return true;
      }
      return false;
    }

    async function loadHistoricalKlines() {
      if (loadHistoricalKlinesFromStorage()) {
        return;
      }
      try {
        const response = await fetch(klineRestUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (!Array.isArray(data)) {
          throw new Error("Invalid kline data format");
        }
        candlesData = data.map(kline => ({
          time: Math.floor(kline[0] / 1000),
          open: parseFloat(kline[1]),
          high: parseFloat(kline[2]),
          low: parseFloat(kline[3]),
          close: parseFloat(kline[4]),
        }));
        if (candlestickSeries && candlesData.length > 0) {
          candlestickSeries.setData(candlesData);
          chart.timeScale().fitContent();
          saveHistoricalKlines();
        }
      } catch (error) {
        console.error('Error loading historical klines:', error);
        document.getElementById("error-message").innerText = "Error loading historical data: " + error.message;
      }
    }

    let isChangingTimeframe = false;
    let lastCandleTime = null;

    function setupKlineSocket() {
      if (klineSocket) {
        klineSocket.close();
        klineSocket = null;
      }
      klineSocket = new WebSocket(klineWsUrl);
      klineSocket.onopen = () => {
        klineReconnectAttempts = 0;
        document.getElementById("websocket-status").innerText = "Connected";
      };
      klineSocket.onclose = (event) => {
        document.getElementById("websocket-status").innerText = "Disconnected";
        if (!isChangingTimeframe && klineReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          klineReconnectAttempts++;
          setTimeout(() => {
            setupKlineSocket();
          }, RECONNECT_DELAY_MS * klineReconnectAttempts);
        } else if (klineReconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
          document.getElementById("error-message").innerText = "Max reconnection attempts reached for Kline WebSocket.";
        }
      };
      klineSocket.onerror = (error) => {
        console.error('Kline WebSocket error:', error);
        document.getElementById("websocket-status").innerText = "WebSocket Error";
        document.getElementById("error-message").innerText = "Kline WebSocket error occurred: " + (error.message || "Unknown error");
      };
      klineSocket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (!data || !data.k) {
            throw new Error("Invalid kline data format");
          }
          const kline = data.k;
          const time = Math.floor(kline.t / 1000);
          const open = parseFloat(kline.o);
          const high = parseFloat(kline.h);
          const low = parseFloat(kline.l);
          const close = parseFloat(kline.c);

          if (isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
            throw new Error("Invalid kline values");
          }

          const candleData = { time, open, high, low, close };
          if (lastCandleTime && lastCandleTime === time) {
            const lastCandleIndex = candlesData.findIndex(c => c.time === time);
            if (lastCandleIndex !== -1) {
              candlesData[lastCandleIndex] = candleData;
              candlestickSeries.update(candleData);
            }
          } else {
            candlesData.push(candleData);
            if (candlesData.length > 1000) {
              candlesData.shift();
            }
            candlestickSeries.setData(candlesData);
            chart.timeScale().scrollToRealTime();
            lastCandleTime = time;
            saveHistoricalKlines();
          }
        } catch (error) {
          console.error('Error processing kline message:', error);
          document.getElementById("error-message").innerText = "Error processing kline data: " + error.message;
        }
      };
    }

    function changeTimeframe() {
      if (isChangingTimeframe) return;
      isChangingTimeframe = true;
      const newTimeframe = document.getElementById("timeframe-selector").value;
      if (newTimeframe === currentTimeframe) {
        isChangingTimeframe = false;
        return;
      }
      currentTimeframe = newTimeframe;
      klineWsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${currentTimeframe}`;
      klineRestUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${currentTimeframe}&limit=100`;

      if (klineSocket) {
        klineSocket.onclose = null;
        klineSocket.close();
        klineSocket = null;
      }

      candlesData = [];
      lastCandleTime = null;

      loadHistoricalKlines().then(() => {
        setupKlineSocket();
        ensureChartVisibility();
        isChangingTimeframe = false;
      }).catch((error) => {
        console.error('Error in changeTimeframe:', error);
        isChangingTimeframe = false;
        document.getElementById("error-message").innerText = "Error changing timeframe: " + error.message;
      });
    }

    function autoScaleChart() {
      if (chart) {
        chart.timeScale().fitContent();
        chart.priceScale().applyOptions({
          autoScale: true,
        });
      }
    }

    function exportLines() {
      const linesData = Array.from(selectedPrices.entries()).map(([price, line]) => ({
        price: price,
        color: line.isAsk ? '#ff0000' : '#00ff00',
        isAsk: line.isAsk,
      }));
      const blob = new Blob([JSON.stringify(linesData)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'selected_lines.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function updateZones() {
      maxZones = parseInt(document.getElementById("zones-selector").value);
      scheduleTableUpdate();
    }

    function initializeApp() {
      fetchPairs();
      initializeChart();
      if (chart && candlestickSeries) {
        loadHistoricalKlines().then(() => {
          setupKlineSocket();
          loadSelectedPrices();
        }).catch((error) => {
          console.error('Error initializing app:', error);
          document.getElementById("error-message").innerText = "Error initializing app: " + error.message;
        });
      }
    }

    function waitForLightweightCharts() {
      if (typeof LightweightCharts !== 'undefined') {
        initializeApp();
      } else {
        setTimeout(waitForLightweightCharts, 100);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      waitForLightweightCharts();
    });

    function saveSelectedPrices() {
      const prices = Array.from(selectedPrices.entries()).map(([price, line]) => ({
        price: price,
        isAsk: line.isAsk,
      }));
      localStorage.setItem('selectedPrices', JSON.stringify(prices));
    }

    function loadSelectedPrices() {
      const savedPrices = localStorage.getItem('selectedPrices');
      if (savedPrices) {
        const prices = JSON.parse(savedPrices);
        prices.forEach(item => {
          const priceNum = parseFloat(item.price);
          const isAsk = item.isAsk;
          if (!isNaN(priceNum) && !selectedPrices.has(priceNum)) {
            drawSelectedPriceLine(priceNum, null, isAsk);
          }
        });
      }
    }

    function drawSelectedPriceLine(price, row, isAsk) {
      if (selectedPrices.has(price)) {
        const line = selectedPrices.get(price);
        if (line.marker) {
          line.series.removePriceLine(line.marker);
        }
        chart.removeSeries(line.series);
        selectedPrices.delete(price);
        if (row) {
          row.classList.remove("selected-row");
          updateSelectButton(row, price);
        }
        saveSelectedPrices();
        ensureChartVisibility();
        return;
      }

      const lineColor = isAsk ? '#ff0000' : '#00ff00';
      const lineSeries = chart.addLineSeries({
        color: lineColor,
        lineWidth: 1,
        priceLineVisible: false,
        lastValueVisible: false,
      });

      const now = Math.floor(Date.now() / 1000);
      lineSeries.setData([
        { time: now - 86400, value: price },
        { time: now, value: price },
      ]);

      lineSeries.createPriceLine({
        price: price,
        color: lineColor,
        lineWidth: 1,
        lineStyle: LightweightCharts.LineStyle.Solid,
        title: `Price: ${formatPrice(price)}`,
      });

      selectedPrices.set(price, { series: lineSeries, price: price, isAsk: isAsk, marker: null });
      if (row) {
        row.classList.add("selected-row");
        updateSelectButton(row, price);
      }
      saveSelectedPrices();
      ensureChartVisibility();
    }

    function updateSelectButton(row, price) {
      const selectCell = row.querySelector('td:last-child');
      if (selectCell) {
        if (selectedPrices.has(price)) {
          selectCell.innerHTML = `<button class="select-price-btn" data-price="${price}">ð</button>`;
        } else {
          selectCell.innerHTML = `<span class="select-circle" data-price="${price}"></span>`;
        }
      }
    }

    function redrawSelectedLines() {
      const pricesToRedraw = Array.from(selectedPrices.entries()).map(([price, lineData]) => ({
        price: price,
        isAsk: lineData.isAsk,
      }));
      selectedPrices.forEach((value, price) => {
        if (value.series) {
          if (value.marker) {
            value.series.removePriceLine(value.marker);
          }
          chart.removeSeries(value.series);
        }
      });
      selectedPrices.clear();
      pricesToRedraw.forEach(item => {
        drawSelectedPriceLine(item.price, null, item.isAsk);
      });
      ensureChartVisibility();
    }

    window.addEventListener('resize', () => {
      if (chart) {
        const chartContainer = document.getElementById("chart-container");
        chart.resize(chartContainer.offsetWidth, 400);
        redrawSelectedLines();
      }
    });

    function setupEventListeners() {
      const tableBodies = document.querySelectorAll('#asks-body, #bids-body');
      tableBodies.forEach(tableBody => {
        const isAsk = tableBody.id === 'asks-body';
        tableBody.addEventListener('click', (event) => {
          const selectBtn = event.target.closest('.select-price-btn, .select-circle');
          if (selectBtn) {
            event.stopPropagation();
            event.preventDefault();
            const price = parseFloat(selectBtn.dataset.price);
            const row = selectBtn.closest('tr');
            if (row) {
              isInteracting = true;
              drawSelectedPriceLine(price, row, isAsk);
              setTimeout(() => {
                isInteracting = false;
              }, INTERACTION_TIMEOUT_MS);
            }
          }
        });

        tableBody.addEventListener('click', (event) => {
          const priceCell = event.target.closest('.price-cell');
          if (priceCell) {
            event.stopPropagation();
            event.preventDefault();
            isInteracting = true;
            copyPriceCell(priceCell);
            setTimeout(() => {
              isInteracting = false;
            }, INTERACTION_TIMEOUT_MS);
          }
        });
      });
    }

    function setupTickerSocket() {
      const tickerSocket = new WebSocket(tickerWsUrl);
      tickerSocket.onopen = () => {
        console.log('Ticker WebSocket opened');
      };
      tickerSocket.onclose = (event) => {
        console.log('Ticker WebSocket closed:', event);
        setTimeout(() => {
          setupTickerSocket();
        }, RECONNECT_DELAY_MS);
      };
      tickerSocket.onerror = (error) => {
        console.error('Ticker WebSocket error:', error);
        document.getElementById("error-message").innerText = "Ticker WebSocket error occurred: " + (error.message || "Unknown error");
      };
      tickerSocket.onmessage = (event) => {
        try {
          const startTime = performance.now();
          const data = JSON.parse(event.data);
          if (!Array.isArray(data)) {
            throw new Error("Invalid ticker data format");
          }
          const symbolData = data.find(item => item && item.s === symbol.toUpperCase());
          if (symbolData && symbolData.c) {
            const newPrice = parseFloat(symbolData.c);
            if (isNaN(newPrice)) {
              throw new Error("Invalid price value in ticker data");
            }
            currentPrice = newPrice;
            document.getElementById("current-price").innerText = `${symbol} Price: ${formatPrice(currentPrice)}`;
            const endTime = performance.now();
            const timeSinceLastUpdate = startTime - lastPriceUpdateTime;
            lastPriceUpdateTime = startTime;
            updateTimestamp();
            scheduleTableUpdate();
          }
        } catch (error) {
          console.error('Error processing ticker message:', error);
          document.getElementById("error-message").innerText = "Error processing ticker data: " + error.message;
        }
      };
      return tickerSocket;
    }

    function setupDepthSocket() {
      const depthSocket = new WebSocket(depthWsUrl);
      depthSocket.onopen = () => {
        console.log('Depth WebSocket opened');
      };
      depthSocket.onclose = (event) => {
        console.log('Depth WebSocket closed:', event);
        setTimeout(() => {
          setupDepthSocket();
        }, RECONNECT_DELAY_MS);
      };
      depthSocket.onerror = (error) => {
        console.error('Depth WebSocket error:', error);
        document.getElementById("error-message").innerText = "Depth WebSocket error occurred: " + (error.message || "Unknown error");
      };
      depthSocket.onmessage = (event) => {
        try {
          const startTime = performance.now();
          const data = JSON.parse(event.data);
          if (!data || (!data.a && !data.b)) {
            throw new Error("Invalid depth data format");
          }
          const now = Date.now();

          if (data.a) {
            asksData = updateOrders(asksData, data.a, now, true);
            asksProcessed += data.a.length;
          }
          if (data.b) {
            bidsData = updateOrders(bidsData, data.b, now, false);
            bidsProcessed += data.b.length;
          }

          diffOrderbookProcessed = Math.abs(asksProcessed - bidsProcessed);

          if (currentPrice > 0) {
            asksData = asksData.filter(item => {
              const diff = Math.abs((item.price - currentPrice) / currentPrice) * 100;
              return diff <= 10;
            });
            bidsData = bidsData.filter(item => {
              const diff = Math.abs((item.price - currentPrice) / currentPrice) * 100;
              return diff <= 10;
            });
          }

          asksData.sort((a, b) => b.usdt - a.usdt);
          bidsData.sort((a, b) => b.usdt - a.usdt);

          asksData = asksData.slice(0, maxZones);
          bidsData = bidsData.slice(0, maxZones);

          document.getElementById("diff-orderbook").innerText = diffOrderbookProcessed.toLocaleString();
          document.getElementById("asks-total").innerText = `ASKS - ${asksData.length} | TOTAL: ${asksProcessed.toLocaleString()}`;
          document.getElementById("bids-total").innerText = `BIDS - ${bidsData.length} | TOTAL: ${bidsProcessed.toLocaleString()}`;
          const totalPrices = asksProcessed + bidsProcessed;
          document.getElementById("total-prices").innerText = totalPrices.toLocaleString();

          if (totalPrices > 250000) {
            document.getElementById("total-prices").classList.add("highlight-total");
          }

          const asksIndicatorStart = document.getElementById("asks-indicator-start");
          const asksIndicatorEnd = document.getElementById("asks-indicator-end");
          const bidsIndicatorStart = document.getElementById("bids-indicator-start");
          const bidsIndicatorEnd = document.getElementById("bids-indicator-end");
          asksIndicatorStart.classList.remove("circle-red", "circle-green");
          asksIndicatorEnd.classList.remove("circle-red", "circle-green");
          bidsIndicatorStart.classList.remove("circle-red", "circle-green");
          bidsIndicatorEnd.classList.remove("circle-red", "circle-green");
          if (asksProcessed > bidsProcessed) {
            asksIndicatorStart.classList.add("circle-red");
            asksIndicatorEnd.classList.add("circle-red");
          } else if (bidsProcessed > asksProcessed) {
            bidsIndicatorStart.classList.add("circle-green");
            bidsIndicatorEnd.classList.add("circle-green");
          }

          scheduleTableUpdate();
        } catch (error) {
          console.error('Error processing depth message:', error);
          document.getElementById("error-message").innerText = "Error processing depth data: " + error.message;
        }
      };
      return depthSocket;
    }

    tickerSocket = setupTickerSocket();
    depthSocket = setupDepthSocket();
    setupEventListeners();

    function scheduleTableUpdate() {
      if (!pendingUpdate) {
        pendingUpdate = true;
        const now = Date.now();
        if (isInteracting) {
          setTimeout(() => {
            pendingUpdate = false;
            scheduleTableUpdate();
          }, TABLE_UPDATE_DEBOUNCE_MS);
          return;
        }
        if (now - lastTableUpdate < TABLE_UPDATE_DEBOUNCE_MS) {
          setTimeout(() => {
            pendingUpdate = false;
            scheduleTableUpdate();
          }, TABLE_UPDATE_DEBOUNCE_MS - (now - lastTableUpdate));
          return;
        }
        requestAnimationFrame(() => {
          updateTables();
          lastTableUpdate = Date.now();
          pendingUpdate = false;
        });
      }
    }

    function updateOrders(existingOrders, newOrders, now, isAsk) {
      const ordersMap = new Map(existingOrders.map(o => [o.price, o]));

      newOrders.forEach(([p, q]) => {
        const price = parseFloat(p);
        const qty = parseFloat(q);
        if (isNaN(price) || isNaN(qty)) {
          console.warn(`Invalid price or qty: price=${p}, qty=${q}`);
          return;
        }
        const usdt = price * qty;

        if (qty === 0) {
          ordersMap.delete(price);
          rowColors.delete(price);
        } else {
          if (ordersMap.has(price)) {
            const existing = ordersMap.get(price);
            const previousHits = existing.hits || 0;

            existing.qty = qty;
            existing.usdt = usdt;
            existing.lastUpdated = now;
            existing.hits = previousHits + 1;
            existing.colorAssignedTime = now;
          } else {
            ordersMap.set(price, {
              price,
              qty,
              usdt,
              lastUpdated: now,
              colorAssignedTime: now,
              hits: 1,
            });
          }
        }
      });

      return Array.from(ordersMap.values());
    }

    function getColorClass(price, markPrice, isAsk, colorAssignedTime, now) {
      if (!markPrice || markPrice === 0) return "color-transparent";
      const diff = ((price - markPrice) / markPrice) * 100;
      const absDiff = Math.abs(diff);
      const colorAge = now - colorAssignedTime;

      if (colorAge > COLOR_DURATION_MS) {
        return "color-transparent";
      }

      if (absDiff <= 0.1) {
        return "color-orange";
      } else if (absDiff > 0.1 && absDiff <= 0.5) {
        return "color-yellow";
      } else if (absDiff > 0.5 && absDiff <= 1) {
        return "color-blue";
      }
      return "color-transparent";
    }

    function updateTables() {
      updateTable("asks-body", asksData, currentPrice, true);
      updateTable("bids-body", bidsData, currentPrice, false);
    }

    function updateTable(tableId, data, markPrice, isAsk) {
      const tableBody = document.getElementById(tableId);
      const now = Date.now();

      const existingRows = new Map();
      Array.from(tableBody.children).forEach(row => {
        const price = parseFloat(row.cells[2].textContent);
        if (!isNaN(price)) {
          existingRows.set(price, row);
        }
      });

      let accUsdt = 0;
      let accQty = 0;

      const fragment = document.createDocumentFragment();
      data.forEach((item, idx) => {
        const ageTime = formatAge(now - item.lastUpdated);
        const pct = markPrice ? (((item.price - markPrice) / markPrice) * 100).toFixed(3) : "---";
        
        accUsdt += item.usdt;
        accQty += item.qty;

        let row = existingRows.get(item.price);
        if (!row) {
          row = document.createElement("tr");
          row.className = isAsk ? "ask-row" : "bid-row";
        }

        if (selectedPrices.has(item.price)) {
          row.classList.add("selected-row");
        } else {
          row.classList.remove("selected-row");
        }

        if (idx < 4) {
          row.classList.add("highlight-top");
        } else {
          row.classList.remove("highlight-top");
        }

        const newColorClass = getColorClass(item.price, markPrice, isAsk, item.colorAssignedTime || now, now);
        row.classList.remove("color-transparent", "color-blue", "color-yellow", "color-orange");
        row.classList.add(newColorClass);
        rowColors.set(item.price, newColorClass);

        if (newColorClass !== "color-transparent") {
          row.classList.add("bold-row");
        } else {
          row.classList.remove("bold-row");
        }

        const highlightDuration = 1000;
        const timeSinceUpdate = now - item.lastUpdated;
        if (timeSinceUpdate <= highlightDuration && item.hits > 1) {
          row.classList.add(isAsk ? "highlight-red" : "highlight-green");
        } else {
          row.classList.remove("highlight-red", "highlight-green");
        }

        row.innerHTML = `
          <td>${idx + 1}</td>
          <td>${ageTime}</td>
          <td class="price-cell">${formatPrice(item.price)}</td>
          <td>${formatQty(item.qty)}</td>
          <td>${formatUsdt(item.usdt)}</td>
          <td>${pct}</td>
          <td>${formatUsdt(accUsdt)}</td>
          <td>${formatQty(accQty)}</td>
          <td>${item.hits || 1}</td>
          <td>${selectedPrices.has(item.price) ? `<button class="select-price-btn" data-price="${item.price}">ð</button>` : `<span class="select-circle" data-price="${item.price}"></span>`}</td>
        `;
        fragment.appendChild(row);
        existingRows.delete(item.price);
      });

      existingRows.forEach(row => row.remove());
      tableBody.appendChild(fragment);
    }

    function copyPriceCell(cell) {
      const priceText = cell.textContent.trim();
      navigator.clipboard.writeText(priceText).then(() => {
        cell.classList.add("copied");
      }).catch(err => {
        console.error('Error copying price:', err);
      });
    }

    function formatPrice(value) {
      if (isNaN(value)) return "0.00";
      return parseFloat(value).toFixed(2);
    }

    function formatQty(value) {
      if (isNaN(value) || value === 0) return "0";
      if (value >= 1_000_000_000) {
        return (value / 1_000_000_000).toFixed(2) + "b";
      } else if (value >= 1_000_000) {
        return (value / 1_000_000).toFixed(2) + "m";
      } else if (value >= 1_000) {
        return (value / 1_000).toFixed(2) + "k";
      } else if (value < 0.001) {
        return value.toFixed(6);
      }
      return parseFloat(value).toFixed(4);
    }

    function formatUsdt(value) {
      if (isNaN(value) || value === 0) return "0.00";
      if (value >= 1_000_000_000) {
        return (value / 1_000_000_000).toFixed(2) + "b";
      } else if (value >= 1_000_000) {
        return (value / 1_000_000).toFixed(2) + "m";
      } else if (value >= 1_000) {
        return (value / 1_000).toFixed(2) + "k";
      } else if (value < 0.01) {
        return value.toFixed(4);
      }
      return parseFloat(value).toFixed(2);
    }

    function formatAge(ms) {
      const seconds = Math.floor(ms / 1000);
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m`;
      const hours = Math.floor(minutes / 60);
      return `${hours}h`;
    }

    function formatUtcOffset(offset) {
      const sign = offset >= 0 ? "+" : "-";
      const absOffset = Math.abs(offset);
      const hours = Math.floor(absOffset).toString().padStart(2, '0');
      const minutes = ((absOffset % 1) * 60).toString().padStart(2, '0');
      return `UTC${sign}${hours}:${minutes}`;
    }

    function updateTimestamp() {
      const now = new Date('2025-04-19T10:31:43.500Z');
      now.setUTCHours(now.getUTCHours() + utcOffset);
      const options = {
        weekday: 'short',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 1,
        hour12: true,
      };
      let formattedDate = now.toLocaleString('en-US', options);
      formattedDate = formattedDate.replace(/(\d{2})\/(\d{2})\/(\d{4})/, '$3-$1-$2');
      formattedDate += ` ${formatUtcOffset(utcOffset)}`;
      document.getElementById("local-time").innerText = formattedDate;
    }

    updateTimestamp();
  </script>
</body>
</html>
